<!DOCTYPE html>
<html lang="zh-TW" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript 語法完整教學</title>
    <link rel="icon" href="html_favicon.svg" type="image/svg+xml">
    <link rel="stylesheet" href="styles.css">
    <style>
        /* 深色模式下的顏色覆蓋 */
        [data-theme="dark"] {
            --text-color: #e5e5e5;
            --background-color: #1a1a1a;
            --code-bg: #2d2d2d;
            --section-border: #333;
        }
        
        /* 全局文字設定 */
        body {
            color: var(--text-color, #333);
            background-color: var(--background-color, #fff);
            font-family: Arial, sans-serif;
            line-height: 1.6;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1, h2, h3 {
            color: var(--heading-color, #2c3e50);
        }
        
        pre, code {
            background-color: var(--code-bg, #f5f5f5);
        }
        
        .section {
            border-bottom: 1px solid var(--section-border, #eee);
            margin-bottom: 30px;
            padding-bottom: 20px;
        }
        
        [data-theme="dark"] p, 
        [data-theme="dark"] li, 
        [data-theme="dark"] td, 
        [data-theme="dark"] th, 
        [data-theme="dark"] h1, 
        [data-theme="dark"] h2, 
        [data-theme="dark"] h3 {
            color: var(--text-color);
        }
        
        [data-theme="dark"] a {
            color: #6ab0ff;
        }
        
        .runnable-code {
            position: relative;
            margin: 20px 0;
        }
        .code-editor {
            width: 100%;
            min-height: 100px;
            font-family: 'Consolas', 'Monaco', monospace;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f8f8f8;
            resize: vertical;
        }
        [data-theme="dark"] .code-editor {
            background-color: #2d2d2d;
            color: #f8f8f8;
            border-color: #444;
        }
        .copy-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #27ae60;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .copy-button:hover {
            background-color: #219652;
        }
        pre {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        [data-theme="dark"] pre {
            background-color: #2d2d2d;
            color: #f8f8f8;
        }
        code {
            background-color: #f5f5f5;
            padding: 2px 5px;
            border-radius: 4px;
            font-family: Consolas, monospace;
        }
        [data-theme="dark"] code {
            background-color: #2d2d2d;
            color: #f8f8f8;
        }
        
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        [data-theme="dark"] table {
            color: var(--text-color);
        }
        [data-theme="dark"] th {
            background-color: #333;
        }
        [data-theme="dark"] td, [data-theme="dark"] th {
            border-color: #444;
        }
        
        .example {
            border-left: 3px solid #3498db;
            padding-left: 15px;
            margin: 20px 0;
        }
        
        .js-output {
            background-color: #f8f8f8;
            border: 1px solid #ddd;
            padding: 10px;
            margin-top: 10px;
            border-radius: 5px;
        }
        
        [data-theme="dark"] .js-output {
            background-color: #333;
            border-color: #444;
        }
    </style>
</head>
<body>
    <header>
        <div class="header-container">
            <h1>JavaScript 語法完整教學</h1>
            <button id="theme-toggle" aria-label="切換深色/淺色模式">
                <span class="theme-icon light-icon">🌞</span>
                <span class="theme-icon dark-icon">🌙</span>
            </button>
        </div>
        <nav>
            <ul>
                <li><a href="home.html">首頁</a></li>
                <li><a href="#js-basics">JavaScript基礎</a></li>
                <li><a href="#variables">變數與數據類型</a></li>
                <li><a href="#operators">運算符</a></li>
                <li><a href="#control-flow">控制流程</a></li>
                <li><a href="#functions">函數</a></li>
                <li><a href="#arrays">陣列</a></li>
                <li><a href="#objects">物件</a></li>
                <li><a href="#dom">DOM操作</a></li>
                <li><a href="#events">事件處理</a></li>
                <li><a href="#async">異步編程</a></li>
                <li><a href="#error-handling">錯誤處理</a></li>
                <li><a href="#es6plus">ES6+特性</a></li>
                <li><a href="#modules">模組系統</a></li>
                <li><a href="#storage">存儲</a></li>
                <li><a href="#json">JSON操作</a></li>
                <li><a href="#api">API請求</a></li>
                <li><a href="#debugging">調試技巧</a></li>
                <li><a href="#best-practices">最佳實踐</a></li>
            </ul>
        </nav>
    </header>

    <main>
        <section id="introduction">
            <h2>JavaScript 語法完整教學</h2>
            <p>JavaScript是一種高級的、解釋型的程式語言，是網頁開發中不可或缺的一部分。它使網頁具有互動性，並使開發者能夠創建動態內容和Web應用程序。</p>
            <p>本教學將系統地介紹JavaScript的各種語法和概念，從基礎到進階，幫助您掌握這門強大的程式語言。</p>
        </section>

        <section id="js-basics" class="section">
            <h2>1. JavaScript基礎</h2>
            <h3>1.1 什麼是JavaScript？</h3>
            <p>JavaScript是一種輕量級、解釋型或即時編譯型的程式語言，廣泛用於Web開發。它是網頁三大核心技術之一（HTML、CSS、JavaScript）。</p>
            
            <h3>1.2 如何在HTML中使用JavaScript</h3>
            <div class="runnable-code">
                <textarea class="code-editor" id="code-include-js" readonly>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;JavaScript示例&lt;/title&gt;
    &lt;!-- 內部JavaScript --&gt;
    &lt;script&gt;
        // JavaScript代碼放在這裡
        console.log('這是內部JavaScript');
    &lt;/script&gt;
    
    &lt;!-- 外部JavaScript --&gt;
    &lt;script src="script.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 內聯JavaScript --&gt;
    &lt;button onclick="alert('按鈕被點擊了!')"&gt;點擊我&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;</textarea>
                <button class="copy-button" onclick="copyCode('code-include-js')">複製</button>
            </div>
            
            <h3>1.3 JavaScript輸出</h3>
            <p>JavaScript可以通過多種方式顯示數據：</p>
            <ul>
                <li>使用<code>console.log()</code>輸出到控制台</li>
                <li>使用<code>alert()</code>顯示警告框</li>
                <li>使用<code>document.write()</code>寫入到HTML文檔</li>
                <li>使用<code>innerHTML</code>寫入到HTML元素</li>
            </ul>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-output" readonly>// 控制台輸出
console.log('這是控制台輸出');

// 警告框
alert('這是一個警告框');

// 寫入HTML文檔
document.write('這將顯示在頁面上');

// 寫入HTML元素
document.getElementById('demo').innerHTML = '這改變了元素的內容';</textarea>
                <button class="copy-button" onclick="copyCode('code-output')">複製</button>
            </div>
            
            <h3>1.4 JavaScript語法基礎</h3>
            <ul>
                <li>JavaScript語句以分號(;)結束</li>
                <li>JavaScript區分大小寫</li>
                <li>使用//添加單行註釋</li>
                <li>使用/* */添加多行註釋</li>
                <li>JavaScript忽略空格和換行</li>
            </ul>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-syntax" readonly>// 這是單行註釋
console.log('Hello'); // 這行代碼輸出 "Hello"

/* 這是
多行
註釋 */

let x = 5;      // 聲明變數x並賦值為5
let y = 6;      // 聲明變數y並賦值為6
let z = x + y;  // 計算x+y並將結果賦值給z</textarea>
                <button class="copy-button" onclick="copyCode('code-syntax')">複製</button>
            </div>
        </section>

        <section id="variables" class="section">
            <h2>2. 變數與數據類型</h2>
            <h3>2.1 宣告變數</h3>
            <p>在JavaScript中，有三種宣告變數的方式：</p>
            <ul>
                <li><code>var</code>：舊的宣告方式，有函數作用域</li>
                <li><code>let</code>：新的宣告方式，有塊級作用域</li>
                <li><code>const</code>：宣告常量，賦值後不能更改</li>
            </ul>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-variables" readonly>// 使用var宣告變數
var a = 10;
var name = "John";

// 使用let宣告變數（推薦）
let b = 20;
let title = "Developer";

// 使用const宣告常量
const PI = 3.14159;
const API_URL = "https://api.example.com";

// 變數宣告沒有初始值
let c;  // c的值為undefined</textarea>
                <button class="copy-button" onclick="copyCode('code-variables')">複製</button>
            </div>
            
            <h3>2.2 JavaScript數據類型</h3>
            <p>JavaScript有8種基本數據類型：</p>
            <ol>
                <li><code>String</code>：字符串</li>
                <li><code>Number</code>：數值</li>
                <li><code>BigInt</code>：大整數</li>
                <li><code>Boolean</code>：布爾值</li>
                <li><code>undefined</code>：未定義</li>
                <li><code>null</code>：空值</li>
                <li><code>Symbol</code>：唯一標識符</li>
                <li><code>Object</code>：物件（包括Array、Function、Date等）</li>
            </ol>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-datatypes" readonly>// String（字符串）
let name = "小明";
let message = '這是一段文字';

// Number（數值）
let age = 25;
let price = 99.99;

// BigInt（大整數）
let bigNumber = 1234567890123456789012345n;

// Boolean（布爾值）
let isActive = true;
let isLoggedIn = false;

// undefined（未定義）
let unknownVar;
console.log(unknownVar); // undefined

// null（空值）
let emptyValue = null;

// Symbol（唯一標識符）
let id = Symbol('id');

// Object（物件）
let person = {
    firstName: "小明",
    lastName: "王",
    age: 25
};

// Array（陣列，是Object的一種）
let colors = ["紅", "綠", "藍"];

// Date（日期，是Object的一種）
let today = new Date();</textarea>
                <button class="copy-button" onclick="copyCode('code-datatypes')">複製</button>
            </div>
            
            <h3>2.3 typeof操作符</h3>
            <p><code>typeof</code>操作符用於返回變數或表達式的類型：</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-typeof" readonly>console.log(typeof "小明");     // 返回 "string"
console.log(typeof 123);         // 返回 "number"
console.log(typeof true);        // 返回 "boolean"
console.log(typeof undefined);   // 返回 "undefined"
console.log(typeof null);        // 返回 "object"（這是JavaScript的一個bug）
console.log(typeof {});          // 返回 "object"
console.log(typeof []);          // 返回 "object"
console.log(typeof function(){}); // 返回 "function"</textarea>
                <button class="copy-button" onclick="copyCode('code-typeof')">複製</button>
            </div>
        </section>

        <section id="operators" class="section">
            <h2>3. 運算符</h2>
            <h3>3.1 算術運算符</h3>
            <p>用於執行數值計算的基本運算符：</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-arithmetic" readonly>let a = 10;
let b = 3;

// 加法
let sum = a + b;  // 13

// 減法
let difference = a - b;  // 7

// 乘法
let product = a * b;  // 30

// 除法
let quotient = a / b;  // 3.3333...

// 取餘數（模運算）
let remainder = a % b;  // 1

// 冪運算
let power = a ** b;  // 1000 (10^3)

// 增量和減量運算符
let c = 5;
c++;  // 後增量，c變為6
++c;  // 前增量，c變為7
c--;  // 後減量，c變為6
--c;  // 前減量c變為5</textarea>
                <button class="copy-button" onclick="copyCode('code-arithmetic')">複製</button>
            </div>
            
            <h3>3.2 賦值運算符</h3>
            <p>用於給變數賦值的運算符：</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-assignment" readonly>let x = 10;  // 基本賦值

// 複合賦值運算符
x += 5;   // 等同於 x = x + 5 (x現在是15)
x -= 3;   // 等同於 x = x - 3 (x現在是12)
x *= 2;   // 等同於 x = x * 2 (x現在是24)
x /= 4;   // 等同於 x = x / 4 (x現在是6)
x %= 4;   // 等同於 x = x % 4 (x現在是2)
x **= 3;  // 等同於 x = x ** 3 (x現在是8)</textarea>
                <button class="copy-button" onclick="copyCode('code-assignment')">複製</button>
            </div>
            
            <h3>3.3 比較運算符</h3>
            <p>用於比較兩個值並返回布爾結果：</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-comparison" readonly>let a = 5;
let b = 10;
let c = "5";

// 等於（值相等，類型可能不同）
console.log(a == c);  // true

// 嚴格等於（值和類型都相等）
console.log(a === c);  // false

// 不等於
console.log(a != b);  // true

// 嚴格不等於
console.log(a !== c);  // true

// 大於
console.log(b > a);  // true

// 小於
console.log(a < b);  // true

// 大於等於
console.log(a >= 5);  // true

// 小於等於
console.log(b <= 10);  // true</textarea>
                <button class="copy-button" onclick="copyCode('code-comparison')">複製</button>
            </div>
            
            <h3>3.4 邏輯運算符</h3>
            <p>用於組合多個條件的運算符：</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-logical" readonly>let x = 5;
let y = 10;

// 邏輯與(AND) - 兩個條件都為true時返回true
console.log(x > 0 && y > 0);  // true
console.log(x > 10 && y > 0);  // false

// 邏輯或(OR) - 至少一個條件為true時返回true
console.log(x > 0 || y > 0);  // true
console.log(x > 10 || y > 0);  // true
console.log(x > 10 || y > 20);  // false

// 邏輯非(NOT) - 反轉布爾值
console.log(!true);  // false
console.log(!false);  // true
console.log(!(x > y));  // true</textarea>
                <button class="copy-button" onclick="copyCode('code-logical')">複製</button>
            </div>

            <h3>3.5 三元運算符</h3>
            <p>條件運算符，以簡潔的方式編寫條件語句：</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-ternary" readonly>// 語法: 條件 ? 表達式1 : 表達式2
// 如果條件為true，返回表達式1的值，否則返回表達式2的值

let age = 20;
let status = age >= 18 ? "成年" : "未成年";
console.log(status);  // "成年"

// 可以嵌套使用
let score = 75;
let grade = score >= 90 ? "A" : score >= 80 ? "B" : score >= 70 ? "C" : score >= 60 ? "D" : "F";
console.log(grade);  // "C"</textarea>
                <button class="copy-button" onclick="copyCode('code-ternary')">複製</button>
            </div>
        </section>
        
        <section id="control-flow" class="section">
            <h2>4. 控制流程</h2>
            <h3>4.1 條件語句</h3>
            <p>條件語句用於根據不同條件執行不同的操作。</p>
            
            <h4>4.1.1 if、else if、else語句</h4>
            <div class="runnable-code">
                <textarea class="code-editor" id="code-if-else" readonly>// 基本if語句
let hour = 10;

if (hour < 12) {
    console.log("早上好！");
}

// if-else語句
let time = 15;

if (time < 12) {
    console.log("早上好！");
} else {
    console.log("下午好！");
}

// if-else if-else語句
let score = 85;

if (score >= 90) {
    console.log("優秀");
} else if (score >= 80) {
    console.log("良好");
} else if (score >= 70) {
    console.log("一般");
} else if (score >= 60) {
    console.log("及格");
} else {
    console.log("不及格");
}</textarea>
                <button class="copy-button" onclick="copyCode('code-if-else')">複製</button>
            </div>
            
            <h4>4.1.2 switch語句</h4>
            <div class="runnable-code">
                <textarea class="code-editor" id="code-switch" readonly>let day = 3;
let dayName;

switch (day) {
    case 1:
        dayName = "星期一";
        break;
    case 2:
        dayName = "星期二";
        break;
    case 3:
        dayName = "星期三";
        break;
    case 4:
        dayName = "星期四";
        break;
    case 5:
        dayName = "星期五";
        break;
    case 6:
        dayName = "星期六";
        break;
    case 7:
        dayName = "星期日";
        break;
    default:
        dayName = "無效的日期";
}

console.log(dayName);  // 輸出 "星期三"</textarea>
                <button class="copy-button" onclick="copyCode('code-switch')">複製</button>
            </div>
            
            <h3>4.2 循環語句</h3>
            <p>循環語句用於重複執行某段代碼。</p>
            
            <h4>4.2.1 for循環</h4>
            <div class="runnable-code">
                <textarea class="code-editor" id="code-for" readonly>// 基本for循環
for (let i = 0; i < 5; i++) {
    console.log("循環次數：" + i);
}

// 遍歷陣列
let fruits = ["蘋果", "香蕉", "橙子", "葡萄"];
for (let i = 0; i < fruits.length; i++) {
    console.log(fruits[i]);
}

// for...of循環 (ES6)
for (let fruit of fruits) {
    console.log(fruit);
}

// for...in循環 (用於物件屬性遍歷)
let person = {
    firstName: "小明",
    lastName: "李",
    age: 30
};
for (let key in person) {
    console.log(key + ": " + person[key]);
}</textarea>
                <button class="copy-button" onclick="copyCode('code-for')">複製</button>
            </div>
            
            <h4>4.2.2 while和do-while循環</h4>
            <div class="runnable-code">
                <textarea class="code-editor" id="code-while" readonly>// while循環
let i = 0;
while (i < 5) {
    console.log("while循環：" + i);
    i++;
}

// do-while循環（至少執行一次）
let j = 0;
do {
    console.log("do-while循環：" + j);
    j++;
} while (j < 5);</textarea>
                <button class="copy-button" onclick="copyCode('code-while')">複製</button>
            </div>
            
            <h3>4.3 跳轉語句</h3>
            <p>跳轉語句用於控制循環或條件語句的執行流程。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-break-continue" readonly>// break語句 - 跳出循環
for (let i = 0; i < 10; i++) {
    if (i === 5) {
        break;  // 當i等於5時，跳出循環
    }
    console.log("break示例：" + i);
}

// continue語句 - 跳過當前迭代
for (let i = 0; i < 10; i++) {
    if (i % 2 === 0) {
        continue;  // 當i是偶數時，跳過此次迭代
    }
    console.log("continue示例：" + i);  // 只輸出奇數
}</textarea>
                <button class="copy-button" onclick="copyCode('code-break-continue')">複製</button>
            </div>
        </section>

        <section id="functions" class="section">
            <h2>5. 函數</h2>
            <h3>5.1 函數定義與調用</h3>
            <p>函數是可以重複使用的代碼塊，用於執行特定任務。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-function-basics" readonly>// 函數聲明
function greet() {
    console.log("你好！");
}

// 調用函數
greet();  // 輸出 "你好！"

// 帶參數的函數
function greetPerson(name) {
    console.log("你好，" + name + "！");
}

greetPerson("小明");  // 輸出 "你好，小明！"

// 帶返回值的函數
function sum(a, b) {
    return a + b;
}

let result = sum(5, 3);
console.log(result);  // 輸出 8</textarea>
                <button class="copy-button" onclick="copyCode('code-function-basics')">複製</button>
            </div>
            
            <h3>5.2 函數表達式與箭頭函數</h3>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-function-expressions" readonly>// 函數表達式
let greet = function(name) {
    console.log("你好，" + name + "！");
};

greet("小明");  // 輸出 "你好，小明！"

// 箭頭函數 (ES6)
let sum = (a, b) => a + b;

console.log(sum(5, 3));  // 輸出 8

// 多行箭頭函數
let calculateArea = (width, height) => {
    let area = width * height;
    return area;
};

console.log(calculateArea(5, 3));  // 輸出 15</textarea>
                <button class="copy-button" onclick="copyCode('code-function-expressions')">複製</button>
            </div>
            
            <h3>5.3 默認參數與剩餘參數</h3>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-function-parameters" readonly>// 默認參數 (ES6)
function greet(name = "訪客") {
    console.log("你好，" + name + "！");
}

greet();  // 輸出 "你好，訪客！"
greet("小明");  // 輸出 "你好，小明！"

// 剩餘參數 (ES6)
function sum(...numbers) {
    let result = 0;
    for (let num of numbers) {
        result += num;
    }
    return result;
}

console.log(sum(1, 2, 3, 4, 5));  // 輸出 15</textarea>
                <button class="copy-button" onclick="copyCode('code-function-parameters')">複製</button>
            </div>
            
            <h3>5.4 作用域與閉包</h3>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-scope-closure" readonly>// 全局作用域
let globalVar = "我是全局變數";

function testScope() {
    // 函數作用域
    let localVar = "我是局部變數";
    console.log(globalVar);  // 可以訪問全局變數
    console.log(localVar);   // 可以訪問局部變數
}

testScope();
console.log(globalVar);  // 可以訪問全局變數
// console.log(localVar);   // 錯誤！無法訪問函數內的局部變數

// 塊級作用域 (ES6)
if (true) {
    var a = 10;  // var無視塊級作用域
    let b = 20;  // let尊重塊級作用域
    const c = 30;  // const尊重塊級作用域
}
console.log(a);  // 10
// console.log(b);  // 錯誤！b在塊外不可見
// console.log(c);  // 錯誤！c在塊外不可見

// 閉包
function createCounter() {
    let count = 0;  // 私有變數
    
    return function() {
        count++;
        return count;
    };
}

const counter = createCounter();
console.log(counter());  // 1
console.log(counter());  // 2
console.log(counter());  // 3</textarea>
                <button class="copy-button" onclick="copyCode('code-scope-closure')">複製</button>
            </div>
        </section>

        <section id="arrays" class="section">
            <h2>6. 陣列</h2>
            <h3>6.1 陣列創建與訪問</h3>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-array-basics" readonly>// 創建陣列
let fruits = ["蘋果", "香蕉", "橙子"];
let numbers = [1, 2, 3, 4, 5];
let mixed = [1, "文字", true, null, {name: "物件"}];

// 使用Array構造函數
let newArray = new Array(3);  // 創建長度為3的空陣列
let colors = new Array("紅", "綠", "藍");

// 訪問陣列元素
console.log(fruits[0]);  // "蘋果"
console.log(fruits[1]);  // "香蕉"
console.log(fruits[2]);  // "橙子"

// 修改陣列元素
fruits[1] = "草莓";
console.log(fruits);  // ["蘋果", "草莓", "橙子"]

// 陣列屬性
console.log(fruits.length);  // 3</textarea>
                <button class="copy-button" onclick="copyCode('code-array-basics')">複製</button>
            </div>
            
            <h3>6.2 陣列方法</h3>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-array-methods" readonly>let fruits = ["蘋果", "香蕉", "橙子"];

// 添加和刪除元素
fruits.push("葡萄");       // 在末尾添加元素
console.log(fruits);       // ["蘋果", "香蕉", "橙子", "葡萄"]

fruits.pop();              // 刪除末尾元素
console.log(fruits);       // ["蘋果", "香蕉", "橙子"]

fruits.unshift("草莓");    // 在開頭添加元素
console.log(fruits);       // ["草莓", "蘋果", "香蕉", "橙子"]

fruits.shift();            // 刪除開頭元素
console.log(fruits);       // ["蘋果", "香蕉", "橙子"]

// 連接陣列
let moreFruits = ["葡萄", "芒果"];
let allFruits = fruits.concat(moreFruits);
console.log(allFruits);    // ["蘋果", "香蕉", "橙子", "葡萄", "芒果"]

// 切片和拼接
let citrus = allFruits.slice(2, 4);  // 從索引2到索引3（不包括4）
console.log(citrus);       // ["橙子", "葡萄"]

allFruits.splice(1, 2, "獼猴桃", "梨");  // 從索引1開始刪除2個元素，然後插入新元素
console.log(allFruits);    // ["蘋果", "獼猴桃", "梨", "葡萄", "芒果"]

// 查找元素
console.log(allFruits.indexOf("獼猴桃"));  // 1
console.log(allFruits.includes("蘋果"));   // true

// 排序和反轉
let numbers = [3, 1, 4, 1, 5, 9, 2, 6];
numbers.sort();            // 按字母順序排序
console.log(numbers);      // [1, 1, 2, 3, 4, 5, 6, 9]

numbers.reverse();         // 反轉陣列
console.log(numbers);      // [9, 6, 5, 4, 3, 2, 1, 1]</textarea>
                <button class="copy-button" onclick="copyCode('code-array-methods')">複製</button>
            </div>
            
            <h3>6.3 陣列迭代方法</h3>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-array-iteration" readonly>let numbers = [1, 2, 3, 4, 5];

// forEach - 遍歷每個元素
numbers.forEach(function(num) {
    console.log(num * 2);
});

// map - 創建新陣列，其結果是對每個元素調用函數的結果
let doubled = numbers.map(function(num) {
    return num * 2;
});
console.log(doubled);  // [2, 4, 6, 8, 10]

// filter - 創建新陣列，其元素通過函數測試
let evens = numbers.filter(function(num) {
    return num % 2 === 0;
});
console.log(evens);  // [2, 4]

// reduce - 將陣列減少為單個值
let sum = numbers.reduce(function(total, num) {
    return total + num;
}, 0);
console.log(sum);  // 15

// some - 檢查是否至少有一個元素通過測試
let hasEven = numbers.some(function(num) {
    return num % 2 === 0;
});
console.log(hasEven);  // true

// every - 檢查是否所有元素都通過測試
let allEven = numbers.every(function(num) {
    return num % 2 === 0;
});
console.log(allEven);  // false

// 使用箭頭函數簡化
let tripled = numbers.map(num => num * 3);
console.log(tripled);  // [3, 6, 9, 12, 15]</textarea>
                <button class="copy-button" onclick="copyCode('code-array-iteration')">複製</button>
            </div>
        </section>

        <section id="objects" class="section">
            <h2>7. 物件</h2>
            <h3>7.1 物件創建與訪問</h3>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-object-basics" readonly>// 物件字面量
let person = {
    firstName: "小明",
    lastName: "王",
    age: 30,
    email: "xiaoming@example.com",
    isStudent: false,
    address: {
        city: "台北",
        country: "台灣"
    }
};

// 訪問物件屬性
console.log(person.firstName);  // "小明"
console.log(person["lastName"]);  // "王"
console.log(person.address.city);  // "台北"

// 修改屬性
person.age = 31;
person["email"] = "newmail@example.com";
console.log(person.age);  // 31
console.log(person.email);  // "newmail@example.com"

// 添加新屬性
person.phone = "123-456-7890";
console.log(person.phone);  // "123-456-7890"

// 刪除屬性
delete person.isStudent;
console.log(person.isStudent);  // undefined</textarea>
                <button class="copy-button" onclick="copyCode('code-object-basics')">複製</button>
            </div>
            
            <h3>7.2 物件方法</h3>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-object-methods" readonly>// 物件包含方法
let person = {
    firstName: "小明",
    lastName: "王",
    
    // 物件方法
    fullName: function() {
        return this.firstName + " " + this.lastName;
    },
    
    // ES6簡短方法語法
    greet() {
        return "你好，我是 " + this.fullName();
    }
};

console.log(person.fullName());  // "小明 王"
console.log(person.greet());  // "你好，我是 小明 王"

// 獲取所有鍵（屬性名）
let keys = Object.keys(person);
console.log(keys);  // ["firstName", "lastName", "fullName", "greet"]

// 獲取所有值
let values = Object.values(person);
console.log(values);  // ["小明", "王", [Function: fullName], [Function: greet]]

// 獲取所有鍵值對
let entries = Object.entries(person);
console.log(entries);  // [["firstName", "小明"], ["lastName", "王"], ...]

// 檢查屬性是否存在
console.log("firstName" in person);  // true
console.log("age" in person);  // false
console.log(person.hasOwnProperty("firstName"));  // true</textarea>
                <button class="copy-button" onclick="copyCode('code-object-methods')">複製</button>
            </div>
            
            <h3>7.3 構造函數和原型</h3>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-constructors" readonly>// 構造函數
function Person(firstName, lastName, age) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.age = age;
    
    this.fullName = function() {
        return this.firstName + " " + this.lastName;
    };
}

// 創建實例
let person1 = new Person("小明", "王", 30);
let person2 = new Person("小華", "李", 25);

console.log(person1.fullName());  // "小明 王"
console.log(person2.fullName());  // "小華 李"

// 使用原型添加方法 (更高效，所有實例共享同一個方法)
Person.prototype.greet = function() {
    return "你好，我是 " + this.fullName();
};

console.log(person1.greet());  // "你好，我是 小明 王"
console.log(person2.greet());  // "你好，我是 小華 李"</textarea>
                <button class="copy-button" onclick="copyCode('code-constructors')">複製</button>
            </div>
            
            <h3>7.4 ES6類</h3>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-classes" readonly>// ES6類語法
class Person {
    constructor(firstName, lastName, age) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
    }
    
    // 方法
    fullName() {
        return this.firstName + " " + this.lastName;
    }
    
    greet() {
        return `你好，我是 ${this.fullName()}`;
    }
    
    // 靜態方法
    static createAnonymous() {
        return new Person("無名氏", "", 0);
    }
}

// 創建實例
let person1 = new Person("小明", "王", 30);
console.log(person1.fullName());  // "小明 王"
console.log(person1.greet());     // "你好，我是 小明 王"

// 使用靜態方法
let anonymous = Person.createAnonymous();
console.log(anonymous.fullName());  // "無名氏 "

// 繼承
class Student extends Person {
    constructor(firstName, lastName, age, grade) {
        // 呼叫父類構造函數
        super(firstName, lastName, age);  // 呼叫父類構造函數
        this.grade = grade;
    }
    
    study() {
        return `${this.fullName()}正在學習`;
    }
    
    // 覆寫父類方法
    greet() {
        return `你好，我是學生 ${this.fullName()}，我在${this.grade}年級`;
    }
}

let student1 = new Student("小華", "李", 15, "高一");
console.log(student1.fullName());  // "小華 李"
console.log(student1.greet());     // "你好，我是學生 小華 李，我在高一年級"
console.log(student1.study());     // "小華 李正在學習"</textarea>
                <button class="copy-button" onclick="copyCode('code-classes')">複製</button>
            </div>
        </section>
        
        <section id="dom" class="section">
            <h2>8. DOM操作</h2>
            <h3>8.1 什麼是DOM？</h3>
            <p>DOM (Document Object Model) 是HTML和XML文檔的程式介面。它將網頁表示為樹結構，使JavaScript能夠訪問和操作網頁內容。</p>
            
            <div class="example">
                <p>DOM樹結構示例：</p>
                <pre>
document
  └── html
       ├── head
       │    ├── title
       │    └── meta
       └── body
            ├── div
            │    └── p
            └── script
                </pre>
            </div>
            
            <h3>8.2 選擇DOM元素</h3>
            <p>JavaScript提供多種方法來選擇DOM元素：</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-dom-select" readonly>// 通過ID選擇元素
let elementById = document.getElementById('myId');

// 通過類名選擇元素（返回HTMLCollection）
let elementsByClass = document.getElementsByClassName('myClass');

// 通過標籤名選擇元素（返回HTMLCollection）
let elementsByTag = document.getElementsByTagName('div');

// 通過CSS選擇器選擇第一個匹配的元素
let elementByQuery = document.querySelector('.myClass');

// 通過CSS選擇器選擇所有匹配的元素（返回NodeList）
let elementsByQuery = document.querySelectorAll('div.myClass');

// 選擇特定的表單元素
let form = document.forms['myForm'];
let formElement = form.elements['myInput'];</textarea>
                <button class="copy-button" onclick="copyCode('code-dom-select')">複製</button>
            </div>
            
            <h3>8.3 操作DOM元素</h3>
            
            <h4>8.3.1 修改元素內容</h4>
            <div class="runnable-code">
                <textarea class="code-editor" id="code-dom-content" readonly>// 使用innerHTML修改元素的HTML內容
document.getElementById('myElement').innerHTML = '<strong>新的HTML內容</strong>';

// 使用textContent修改元素的文本內容（不解析HTML）
document.getElementById('myElement').textContent = '純文本內容';

// 使用innerText修改元素的可見文本內容
document.getElementById('myElement').innerText = '可見文本內容';</textarea>
                <button class="copy-button" onclick="copyCode('code-dom-content')">複製</button>
            </div>
            
            <h4>8.3.2 修改元素屬性</h4>
            <div class="runnable-code">
                <textarea class="code-editor" id="code-dom-attributes" readonly>// 設置屬性
document.getElementById('myImage').src = 'new-image.jpg';
document.getElementById('myLink').href = 'https://example.com';

// 使用setAttribute方法
document.getElementById('myElement').setAttribute('class', 'newClass');

// 獲取屬性
let imgSrc = document.getElementById('myImage').src;
let attrValue = document.getElementById('myElement').getAttribute('data-custom');

// 刪除屬性
document.getElementById('myElement').removeAttribute('disabled');</textarea>
                <button class="copy-button" onclick="copyCode('code-dom-attributes')">複製</button>
            </div>
            
            <h4>8.3.3 修改元素樣式</h4>
            <div class="runnable-code">
                <textarea class="code-editor" id="code-dom-styles" readonly>// 直接修改行內樣式
let element = document.getElementById('myElement');
element.style.color = 'red';
element.style.fontSize = '20px';
element.style.backgroundColor = '#f0f0f0';

// 一次修改多個樣式（使用cssText）
element.style.cssText = 'color: blue; font-size: 16px; padding: 10px;';

// 使用classList添加/移除/切換類
element.classList.add('highlight');
element.classList.remove('old-class');
element.classList.toggle('active');
element.classList.replace('old-class', 'new-class');

// 檢查是否包含某個類
let hasClass = element.classList.contains('highlight');</textarea>
                <button class="copy-button" onclick="copyCode('code-dom-styles')">複製</button>
            </div>
            
            <h3>8.4 創建和刪除元素</h3>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-dom-create-remove" readonly>// 創建新元素
let newDiv = document.createElement('div');
let newText = document.createTextNode('這是新創建的文本');

// 設置新元素的屬性和內容
newDiv.id = 'newDiv';
newDiv.className = 'container';
newDiv.appendChild(newText);  // 添加文本到div
newDiv.innerHTML = '<span>使用innerHTML設置內容</span>';

// 將新元素添加到DOM中
document.body.appendChild(newDiv);  // 添加到body末尾
document.getElementById('parent').prepend(newDiv);  // 添加到父元素開頭

// 在特定元素前/後插入
let referenceElement = document.getElementById('reference');
referenceElement.parentNode.insertBefore(newDiv, referenceElement);  // 在參考元素前插入
referenceElement.after(newDiv);  // 在參考元素後插入（新方法）

// 替換元素
let oldElement = document.getElementById('old');
oldElement.parentNode.replaceChild(newDiv, oldElement);
// 或使用新方法
oldElement.replaceWith(newDiv);

// 刪除元素
let elementToRemove = document.getElementById('toRemove');
elementToRemove.parentNode.removeChild(elementToRemove);
// 或使用新方法
elementToRemove.remove();</textarea>
                <button class="copy-button" onclick="copyCode('code-dom-create-remove')">複製</button>
            </div>
            
            <h3>8.5 DOM節點關係</h3>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-dom-traversing" readonly>let element = document.getElementById('myElement');

// 父節點
let parent = element.parentNode;  // 獲取父節點
let parentElement = element.parentElement;  // 獲取父元素節點

// 子節點
let children = element.childNodes;  // 所有子節點（包括文本和註釋）
let childElements = element.children;  // 僅子元素節點
let firstChild = element.firstChild;  // 第一個子節點
let firstElement = element.firstElementChild;  // 第一個子元素
let lastChild = element.lastChild;  // 最後一個子節點
let lastElement = element.lastElementChild;  // 最後一個子元素
let childCount = element.childElementCount;  // 子元素數量

// 兄弟節點
let next = element.nextSibling;  // 下一個兄弟節點
let nextElement = element.nextElementSibling;  // 下一個兄弟元素
let previous = element.previousSibling;  // 上一個兄弟節點
let previousElement = element.previousElementSibling;  // 上一個兄弟元素</textarea>
                <button class="copy-button" onclick="copyCode('code-dom-traversing')">複製</button>
            </div>
        </section>

        <section id="events" class="section">
            <h2>9. 事件處理</h2>
            <h3>9.1 什麼是事件？</h3>
            <p>事件是用戶或瀏覽器執行的動作，如點擊按鈕、載入頁面或提交表單。JavaScript可以偵測這些事件並作出反應。</p>
            
            <h3>9.2 事件處理方法</h3>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-events-handlers" readonly>// 方法1：HTML屬性（不推薦）
// <button onclick="alert('按鈕被點擊了')">點擊我</button>

// 方法2：DOM屬性
let button = document.getElementById('myButton');
button.onclick = function() {
    alert('按鈕被點擊了');
};

// 方法3：addEventListener（推薦）
button.addEventListener('click', function() {
    alert('按鈕被點擊了（使用addEventListener）');
});

// 使用命名函數作為事件處理器
function handleClick() {
    alert('處理點擊事件');
}
button.addEventListener('click', handleClick);

// 移除事件監聽器
button.removeEventListener('click', handleClick);</textarea>
                <button class="copy-button" onclick="copyCode('code-events-handlers')">複製</button>
            </div>
            
            <h3>9.3 常見事件類型</h3>
            
            <table>
                <tr>
                    <th>事件類別</th>
                    <th>事件名稱</th>
                    <th>說明</th>
                </tr>
                <tr>
                    <td rowspan="3">滑鼠事件</td>
                    <td>click</td>
                    <td>當元素被點擊時</td>
                </tr>
                <tr>
                    <td>mouseover / mouseout</td>
                    <td>當滑鼠指針進入/離開元素時</td>
                </tr>
                <tr>
                    <td>mousedown / mouseup</td>
                    <td>當在元素上按下/釋放滑鼠按鈕時</td>
                </tr>
                <tr>
                    <td rowspan="2">鍵盤事件</td>
                    <td>keydown / keyup</td>
                    <td>當鍵盤按鍵被按下/釋放時</td>
                </tr>
                <tr>
                    <td>keypress</td>
                    <td>當按鍵被按下並產生字符時（已棄用）</td>
                </tr>
                <tr>
                    <td rowspan="2">表單事件</td>
                    <td>submit</td>
                    <td>當表單被提交時</td>
                </tr>
                <tr>
                    <td>change / input</td>
                    <td>當表單元素的值改變時</td>
                </tr>
                <tr>
                    <td rowspan="2">文檔/窗口事件</td>
                    <td>load / DOMContentLoaded</td>
                    <td>當頁面或DOM完成載入時</td>
                </tr>
                <tr>
                    <td>resize / scroll</td>
                    <td>當窗口調整大小或頁面滾動時</td>
                </tr>
            </table>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-events-examples" readonly>// 滑鼠事件
document.getElementById('myElement').addEventListener('click', function(event) {
    console.log('元素被點擊了');
});

document.getElementById('myElement').addEventListener('mouseover', function(event) {
    this.style.backgroundColor = 'yellow';
});

document.getElementById('myElement').addEventListener('mouseout', function(event) {
    this.style.backgroundColor = '';
});

// 鍵盤事件
document.addEventListener('keydown', function(event) {
    console.log('鍵被按下：' + event.key);
    if (event.key === 'Enter') {
        alert('你按下了Enter鍵！');
    }
});

// 表單事件
document.getElementById('myForm').addEventListener('submit', function(event) {
    event.preventDefault();  // 阻止表單提交
    console.log('表單已提交');
});

document.getElementById('myInput').addEventListener('change', function(event) {
    console.log('輸入值已改變為：' + this.value);
});

document.getElementById('myInput').addEventListener('input', function(event) {
    console.log('正在輸入：' + this.value);
});

// 文檔/窗口事件
window.addEventListener('load', function(event) {
    console.log('頁面完全載入，包括所有依賴資源');
});

document.addEventListener('DOMContentLoaded', function(event) {
    console.log('DOM結構已完全載入和解析');
});

window.addEventListener('resize', function(event) {
    console.log('窗口大小已改變');
});

window.addEventListener('scroll', function(event) {
    console.log('頁面已滾動');
});</textarea>
                <button class="copy-button" onclick="copyCode('code-events-examples')">複製</button>
            </div>
            
            <h3>9.4 事件對象</h3>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-event-object" readonly>document.getElementById('myButton').addEventListener('click', function(event) {
    // 事件對象的通用屬性
    console.log('事件類型：' + event.type);  // "click"
    console.log('事件目標：' + event.target);  // 被點擊的元素
    console.log('當前目標：' + event.currentTarget);  // 附加事件處理器的元素
    console.log('事件時間戳：' + event.timeStamp);
    
    // 滑鼠事件特有屬性
    console.log('滑鼠位置：' + event.clientX + ', ' + event.clientY);  // 相對於視窗
    console.log('按下的按鈕：' + event.button);  // 0=左鍵, 1=中鍵, 2=右鍵
    
    // 阻止默認行為
    event.preventDefault();
    
    // 阻止事件冒泡
    event.stopPropagation();
});

// 鍵盤事件對象
document.addEventListener('keydown', function(event) {
    console.log('按鍵：' + event.key);  // 按鍵值
    console.log('鍵碼：' + event.keyCode);  // 已棄用
    console.log('Alt鍵：' + event.altKey);  // 是否按下Alt鍵
    console.log('Ctrl鍵：' + event.ctrlKey);  // 是否按下Ctrl鍵
    console.log('Shift鍵：' + event.shiftKey);  // 是否按下Shift鍵
});</textarea>
                <button class="copy-button" onclick="copyCode('code-event-object')">複製</button>
            </div>
            
            <h3>9.5 事件傳播：冒泡與捕獲</h3>
            
            <div class="example">
                <p>事件傳播的三個階段：</p>
                <ol>
                    <li><strong>捕獲階段</strong>：事件從Window向下傳播到目標元素</li>
                    <li><strong>目標階段</strong>：事件到達目標元素</li>
                    <li><strong>冒泡階段</strong>：事件從目標元素向上冒泡到Window</li>
                </ol>
            </div>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-event-propagation" readonly>// 默認情況下，事件處理器在冒泡階段執行
document.getElementById('child').addEventListener('click', function(event) {
    console.log('子元素被點擊');
});

document.getElementById('parent').addEventListener('click', function(event) {
    console.log('父元素被點擊');  // 點擊子元素時也會執行
});

// 設置為捕獲階段執行（第三個參數為true）
document.getElementById('parent').addEventListener('click', function(event) {
    console.log('父元素捕獲階段');
}, true);

document.getElementById('child').addEventListener('click', function(event) {
    console.log('子元素捕獲階段');
}, true);

// 點擊子元素時的執行順序：
// 1. 父元素捕獲階段
// 2. 子元素捕獲階段
// 3. 子元素被點擊（冒泡階段）
// 4. 父元素被點擊（冒泡階段）

// 阻止冒泡
document.getElementById('child').addEventListener('click', function(event) {
    console.log('子元素被點擊');
    event.stopPropagation();  // 阻止事件冒泡，父元素的處理器不會執行
});</textarea>
                <button class="copy-button" onclick="copyCode('code-event-propagation')">複製</button>
            </div>
            
            <h3>9.6 事件委派</h3>
            <p>事件委派是一種利用事件冒泡的技術，它允許我們將事件監聽器添加到父元素，而不是每個子元素。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-event-delegation" readonly>// 不使用事件委派（效率低下）
let items = document.getElementsByClassName('item');
for (let i = 0; i < items.length; i++) {
    items[i].addEventListener('click', function(event) {
        console.log('點擊了項目：' + this.textContent);
    });
}

// 使用事件委派（更高效）
document.getElementById('itemList').addEventListener('click', function(event) {
    if (event.target.className === 'item') {
        console.log('點擊了項目：' + event.target.textContent);
    }
});

// 動態添加元素時，事件委派特別有用
let newItem = document.createElement('li');
newItem.className = 'item';
newItem.textContent = '新項目';
document.getElementById('itemList').appendChild(newItem);
// 新添加的項目自動具有點擊功能，不需要單獨添加事件監聽器</textarea>
                <button class="copy-button" onclick="copyCode('code-event-delegation')">複製</button>
            </div>
        </section>

        <section id="async" class="section">
            <h2>10. 異步編程</h2>
            <h3>10.1 同步與異步編程</h3>
            <p>同步代碼按順序執行，每條語句完成後才執行下一條。異步代碼允許其他代碼在等待操作完成時繼續執行。</p>
            
            <div class="example">
                <p><strong>同步代碼問題</strong>：如果某個操作耗時較長（如網絡請求），它會阻塞所有後續代碼的執行，導致頁面凍結。</p>
                <p><strong>異步編程解決方案</strong>：使用回調函數、Promise或async/await等技術處理耗時操作，使代碼不會被阻塞。</p>
            </div>
            
            <h3>10.2 回調函數</h3>
            <p>回調函數是傳遞給另一個函數的函數，它將在特定事件發生或任務完成時執行。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-callbacks" readonly>// 基本回調示例
function greeting(name, callback) {
    console.log('你好，' + name);
    callback();
}

greeting('小明', function() {
    console.log('回調函數執行完畢');
});

// 異步操作的回調示例
setTimeout(function() {
    console.log('3秒後執行');
}, 3000);

// 回調地獄（Callback Hell）
setTimeout(function() {
    console.log('第一步');
    setTimeout(function() {
        console.log('第二步');
        setTimeout(function() {
            console.log('第三步');
            // 更多嵌套...
        }, 1000);
    }, 1000);
}, 1000);</textarea>
                <button class="copy-button" onclick="copyCode('code-callbacks')">複製</button>
            </div>
            
            <h3>10.3 Promise</h3>
            <p>Promise是現代JavaScript中處理異步操作的標準方式，它表示一個尚未完成但預計在未來完成的操作。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-promises" readonly>// 創建Promise
let promise = new Promise(function(resolve, reject) {
    // 異步操作
    let success = true;
    
    if (success) {
        resolve('操作成功');  // 成功時調用
    } else {
        reject('操作失敗');   // 失敗時調用
    }
});

// 使用Promise
promise
    .then(function(result) {
        console.log(result);  // 處理成功的結果
        return '新結果';      // 返回值將被傳遞到下一個then
    })
    .then(function(newResult) {
        console.log(newResult);  // 處理新結果
    })
    .catch(function(error) {
        console.error(error);  // 處理任何錯誤
    })
    .finally(function() {
        console.log('無論成功或失敗都會執行');
    });

// Promise鏈，解決回調地獄問題
function step1() {
    return new Promise((resolve) => {
        setTimeout(() => {
            console.log('第一步');
            resolve('第一步完成');
        }, 1000);
    });
}

function step2(message) {
    return new Promise((resolve) => {
        setTimeout(() => {
            console.log(message);
            console.log('第二步');
            resolve('第二步完成');
        }, 1000);
    });
}

function step3(message) {
    return new Promise((resolve) => {
        setTimeout(() => {
            console.log(message);
            console.log('第三步');
            resolve('全部完成');
        }, 1000);
    });
}

step1()
    .then(step2)
    .then(step3)
    .then((result) => {
        console.log(result);
    });</textarea>
                <button class="copy-button" onclick="copyCode('code-promises')">複製</button>
            </div>
            
            <h3>10.4 async/await</h3>
            <p>async/await是基於Promise構建的語法糖，使異步代碼看起來更像同步代碼，更易讀和維護。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-async-await" readonly>// 異步函數
async function fetchData() {
    return '數據';  // 自動包裝為Promise
}

// 使用await等待Promise解析
async function processData() {
    try {
        console.log('開始獲取數據');
        let data = await fetchData();  // 等待Promise解析
        console.log('獲取的數據：', data);
        return '處理完成';
    } catch (error) {
        console.error('發生錯誤：', error);
    } finally {
        console.log('清理工作');
    }
}

// 調用異步函數
processData().then(result => {
    console.log(result);
});

// 使用async/await重寫上面的步驟示例
async function executeSteps() {
    try {
        const result1 = await step1();
        const result2 = await step2(result1);
        const result3 = await step3(result2);
        console.log(result3);
    } catch (error) {
        console.error('執行步驟時出錯：', error);
    }
}

executeSteps();</textarea>
                <button class="copy-button" onclick="copyCode('code-async-await')">複製</button>
            </div>
            
            <h3>10.5 實際應用：數據獲取</h3>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-fetch" readonly>// 使用fetch API獲取數據
function fetchUserData() {
    fetch('https://jsonplaceholder.typicode.com/users/1')
        .then(response => {
            if (!response.ok) {
                throw new Error('網絡響應不正常');
            }
            return response.json();
        })
        .then(user => {
            console.log('用戶數據：', user);
        })
        .catch(error => {
            console.error('獲取數據出錯：', error);
        });
}

// 使用async/await和fetch
async function fetchUserDataAsync() {
    try {
        const response = await fetch('https://jsonplaceholder.typicode.com/users/1');
        
        if (!response.ok) {
            throw new Error('網絡響應不正常');
        }
        
        const user = await response.json();
        console.log('用戶數據：', user);
        return user;
    } catch (error) {
        console.error('獲取數據出錯：', error);
    }
}

// 並行請求多個資源
async function fetchMultipleResources() {
    try {
        const [usersResponse, postsResponse] = await Promise.all([
            fetch('https://jsonplaceholder.typicode.com/users'),
            fetch('https://jsonplaceholder.typicode.com/posts')
        ]);
        
        const users = await usersResponse.json();
        const posts = await postsResponse.json();
        
        console.log('用戶：', users.length);
        console.log('文章：', posts.length);
    } catch (error) {
        console.error('獲取資源時出錯：', error);
    }
}</textarea>
                <button class="copy-button" onclick="copyCode('code-fetch')">複製</button>
            </div>
        </section>
        
        <section id="error-handling" class="section">
            <h2>11. 錯誤處理</h2>
            <h3>11.1 JavaScript錯誤類型</h3>
            <p>JavaScript有幾種內置的錯誤類型：</p>
            
            <table>
                <tr>
                    <th>錯誤類型</th>
                    <th>描述</th>
                    <th>示例</th>
                </tr>
                <tr>
                    <td>SyntaxError</td>
                    <td>語法錯誤</td>
                    <td>if (x ===</td>
                </tr>
                <tr>
                    <td>ReferenceError</td>
                    <td>引用未聲明的變數</td>
                    <td>console.log(undefinedVar)</td>
                </tr>
                <tr>
                    <td>TypeError</td>
                    <td>值的類型與預期不符</td>
                    <td>"hello".push()</td>
                </tr>
                <tr>
                    <td>RangeError</td>
                    <td>數值超出範圍</td>
                    <td>new Array(-1)</td>
                </tr>
                <tr>
                    <td>URIError</td>
                    <td>URI處理函數使用不當</td>
                    <td>decodeURI('%')</td>
                </tr>
                <tr>
                    <td>EvalError</td>
                    <td>eval()使用不當</td>
                    <td>現代JavaScript很少見</td>
                </tr>
            </table>
            
            <h3>11.2 try...catch...finally</h3>
            <p>try...catch語句用於處理可能發生的錯誤，避免程序崩潰。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-try-catch" readonly>// 基本try...catch
try {
    // 可能出錯的代碼
    console.log(nonExistentVariable);
} catch (error) {
    // 處理錯誤
    console.error('發生錯誤:', error.message);
}

// try...catch...finally
try {
    let result = 10 / 0;  // 不會拋出錯誤，但會得到Infinity
    console.log(result);
    let array = null;
    console.log(array.length);  // 這會拋出錯誤
} catch (error) {
    console.error('發生錯誤:', error.message);
} finally {
    // 無論是否有錯誤都會執行
    console.log('finally塊總是執行');
}

// 獲取錯誤信息
try {
    throw new Error('自定義錯誤');
} catch (error) {
    console.error(error.name);     // "Error"
    console.error(error.message);  // "自定義錯誤"
    console.error(error.stack);    // 堆疊追蹤信息
}</textarea>
                <button class="copy-button" onclick="copyCode('code-try-catch')">複製</button>
            </div>
            
            <h3>11.3 拋出自定義錯誤</h3>
            <p>可以使用throw語句拋出自定義錯誤，控制程序流程。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-throw" readonly>// 拋出不同類型的錯誤
throw 'Error occurred';    // 字符串
throw 42;                  // 數字
throw true;                // 布爾值
throw new Error('錯誤信息');  // Error對象（推薦）

// 拋出特定類型的錯誤
throw new SyntaxError('語法錯誤');
throw new ReferenceError('引用錯誤');
throw new TypeError('類型錯誤');
throw new RangeError('範圍錯誤');

// 創建自定義錯誤類型
class ValidationError extends Error {
    constructor(message) {
        super(message);
        this.name = 'ValidationError';
        this.code = 'INVALID_INPUT';
    }
}

// 使用自定義錯誤
function validateUser(user) {
    if (!user.name) {
        throw new ValidationError('用戶名不能為空');
    }
    if (user.age < 0) {
        throw new ValidationError('年齡不能為負數');
    }
}

try {
    validateUser({ name: '', age: 30 });
} catch (error) {
    if (error instanceof ValidationError) {
        console.error('驗證錯誤：', error.message);
    } else {
        console.error('其他錯誤：', error);
    }
}</textarea>
                <button class="copy-button" onclick="copyCode('code-throw')">複製</button>
            </div>
            
            <h3>11.4 錯誤處理策略</h3>
            
            <div class="example">
                <p>有效的錯誤處理策略：</p>
                <ol>
                    <li><strong>預防錯誤</strong>：在錯誤發生前進行數據驗證</li>
                    <li><strong>優雅失敗</strong>：當錯誤發生時提供備用選項</li>
                    <li><strong>明確報告</strong>：提供清晰的錯誤信息</li>
                </ol>
            </div>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-error-strategies" readonly>// 預防錯誤：數據驗證
function divide(a, b) {
    // 檢查參數類型
    if (typeof a !== 'number' || typeof b !== 'number') {
        throw new TypeError('參數必須是數字');
    }
    
    // 防止除以零
    if (b === 0) {
        throw new Error('除數不能為零');
    }
    
    return a / b;
}

// 優雅失敗：提供備用選項
function fetchUserData(userId) {
    try {
        // 嘗試從伺服器獲取數據
        const userData = getUserFromServer(userId);
        return userData;
    } catch (error) {
        console.error('無法從伺服器獲取用戶數據:', error);
        // 使用本地緩存作為備用
        return getUserFromCache(userId) || { name: 'Guest', id: 0 };
    }
}

// 明確報告：記錄詳細錯誤信息
function processOrder(order) {
    try {
        validateOrder(order);
        submitOrder(order);
        return { success: true };
    } catch (error) {
        // 記錄詳細錯誤信息
        logError({
            context: 'Order Processing',
            orderId: order.id,
            error: error.message,
            stack: error.stack,
            timestamp: new Date()
        });
        
        // 向用戶返回友好的錯誤信息
        return { 
            success: false, 
            message: '處理訂單時出錯，請稍後再試' 
        };
    }
}</textarea>
                <button class="copy-button" onclick="copyCode('code-error-strategies')">複製</button>
            </div>
            
            <h3>11.5 異步代碼的錯誤處理</h3>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-async-errors" readonly>// Promise錯誤處理
fetch('https://api.example.com/data')
    .then(response => {
        if (!response.ok) {
            throw new Error('HTTP錯誤：' + response.status);
        }
        return response.json();
    })
    .then(data => {
        console.log('成功獲取數據:', data);
    })
    .catch(error => {
        console.error('獲取數據失敗:', error);
    });

// async/await錯誤處理
async function fetchData() {
    try {
        const response = await fetch('https://api.example.com/data');
        
        if (!response.ok) {
            throw new Error('HTTP錯誤：' + response.status);
        }
        
        const data = await response.json();
        console.log('成功獲取數據:', data);
        return data;
    } catch (error) {
        console.error('獲取數據失敗:', error);
        // 可以重試、回退到緩存或顯示錯誤訊息
        throw error; // 可以選擇重新拋出錯誤
    }
}

// 全局錯誤處理
window.addEventListener('error', function(event) {
    console.error('全局錯誤:', event.message);
    // 可以將錯誤上報到伺服器
    // sendErrorToServer(event.error);
    
    // 防止默認處理（通常不推薦，僅用於特定情況）
    // event.preventDefault();
});

// 處理未捕獲的Promise拒絕
window.addEventListener('unhandledrejection', function(event) {
    console.error('未處理的Promise拒絕:', event.reason);
    // 可以將錯誤上報到伺服器
    // sendErrorToServer(event.reason);
});</textarea>
                <button class="copy-button" onclick="copyCode('code-async-errors')">複製</button>
            </div>
        </section>

        <section id="es6plus" class="section">
            <h2>12. ES6+特性</h2>
            <h3>12.1 變數聲明：let與const</h3>
            <p>ES6引入了新的變數聲明方式：let和const，解決了var的一些問題。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-let-const" readonly>// var的問題
var x = 10;
var x = 20;  // 可以重複聲明
console.log(x);  // 20

// 作用域問題
for (var i = 0; i < 3; i++) {
    // i在循環外仍然可訪問
}
console.log(i);  // 3

// let - 塊級作用域變數
let y = 10;
// let y = 20;  // 錯誤：不能重複聲明

for (let j = 0; j < 3; j++) {
    // j只在循環內可訪問
}
// console.log(j);  // 錯誤：j未定義

// const - 常量（不能重新賦值）
const PI = 3.14159;
// PI = 3.14;  // 錯誤：不能重新賦值

// const與物件
const user = { name: '小明' };
user.name = '小華';  // 可以修改屬性
// user = { name: '小李' };  // 錯誤：不能重新賦值

// 凍結物件以使其完全不可變
const frozenUser = Object.freeze({ name: '小明' });
frozenUser.name = '小華';  // 在嚴格模式下會拋出錯誤，否則靜默失敗
console.log(frozenUser.name);  // 仍然是 '小明'</textarea>
                <button class="copy-button" onclick="copyCode('code-let-const')">複製</button>
            </div>
            
            <h3>12.2 箭頭函數</h3>
            <p>箭頭函數提供了更簡潔的語法來聲明函數，並且不綁定自己的this。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-arrow-functions" readonly>// 傳統函數表達式
const add = function(a, b) {
    return a + b;
};

// 箭頭函數
const addArrow = (a, b) => a + b;

// 單個參數可以省略括號
const square = x => x * x;

// 無參數需要空括號
const getRandomNumber = () => Math.random();

// 多行需要大括號和return
const calculateArea = (width, height) => {
    const area = width * height;
    return area;
};

// this綁定的區別
const traditional = {
    name: '傳統函數',
    sayLater: function() {
        setTimeout(function() {
            console.log(this.name);  // undefined，因為this指向window
        }, 1000);
    }
};

const arrow = {
    name: '箭頭函數',
    sayLater: function() {
        setTimeout(() => {
            console.log(this.name);  // '箭頭函數'，因為箭頭函數不綁定自己的this
        }, 1000);
    }
};</textarea>
                <button class="copy-button" onclick="copyCode('code-arrow-functions')">複製</button>
            </div>
            
            <h3>12.3 模板字符串</h3>
            <p>模板字符串提供了更簡潔的字符串連接方式和多行字符串支持。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-template-strings" readonly>// 傳統字符串連接
const name = '小明';
const greeting = '你好，' + name + '！今天是' + new Date().toLocaleDateString();

// 模板字符串
const templateGreeting = `你好，${name}！今天是${new Date().toLocaleDateString()}`;

// 多行字符串
const multiline = `這是第一行
這是第二行
這是第三行`;

// 嵌套模板
const price = 99.99;
const tax = 0.07;
const total = `總價: $${(price * (1 + tax)).toFixed(2)}`;

// 帶標籤的模板字符串
function highlight(strings, ...values) {
    let result = '';
    strings.forEach((string, i) => {
        result += string;
        if (i < values.length) {
            result += `<strong>${values[i]}</strong>`;
        }
    });
    return result;
}

const product = '筆記本電腦';
const highlightedText = highlight`我買了一個新的${product}，價格是$${price}！`;
console.log(highlightedText);  // "我買了一個新的<strong>筆記本電腦</strong>，價格是$<strong>99.99</strong>！"</textarea>
                <button class="copy-button" onclick="copyCode('code-template-strings')">複製</button>
            </div>
            
            <h3>12.4 解構賦值</h3>
            <p>解構賦值允許從陣列或物件中提取數據並賦值給變數。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-destructuring" readonly>// 陣列解構
const colors = ['紅', '綠', '藍'];

// 傳統方式
const red = colors[0];
const green = colors[1];
const blue = colors[2];

// 解構賦值
const [red2, green2, blue2] = colors;
console.log(red2, green2, blue2);  // 紅 綠 藍

// 跳過元素
const [first, , third] = colors;
console.log(first, third);  // 紅 藍

// 剩餘元素
const [primary, ...secondaryColors] = colors;
console.log(primary, secondaryColors);  // 紅 ['綠', '藍']

// 預設值
const [main = '黑', accent = '白'] = ['黃'];
console.log(main, accent);  // 黃 白

// 物件解構
const person = {
    name: '小明',
    age: 30,
    city: '台北',
    country: '台灣'
};

// 傳統方式
const personName = person.name;
const personAge = person.age;

// 解構賦值
const { name, age } = person;
console.log(name, age);  // 小明 30

// 使用不同的變數名
const { name: fullName, age: years } = person;
console.log(fullName, years);  // 小明 30

// 預設值
const { hobby = '閱讀' } = person;
console.log(hobby);  // 閱讀

// 嵌套解構
const student = {
    id: 1,
    info: {
        firstName: '小',
        lastName: '明',
        scores: [85, 90, 95]
    }
};

const { info: { firstName, lastName, scores: [math, english, science] } } = student;
console.log(firstName, lastName, math, english, science);  // 小 明 85 90 95

// 函數參數解構
function printPersonInfo({ name, age, city = '未知' }) {
    console.log(`${name}, ${age}歲, 來自${city}`);
}

printPersonInfo(person);  // 小明, 30歲, 來自台北</textarea>
                <button class="copy-button" onclick="copyCode('code-destructuring')">複製</button>
            </div>
            
            <h3>12.5 展開運算符與剩餘參數</h3>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-spread-rest" readonly>// 展開運算符 (...)
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

// 合併陣列
const combined = [...arr1, ...arr2];
console.log(combined);  // [1, 2, 3, 4, 5, 6]

// 複製陣列
const copy = [...arr1];
console.log(copy);  // [1, 2, 3]

// 在陣列中間插入元素
const inserted = [...arr1.slice(0, 1), 1.5, ...arr1.slice(1)];
console.log(inserted);  // [1, 1.5, 2, 3]

// 將字符串分解為字符
const chars = [..."Hello"];
console.log(chars);  // ['H', 'e', 'l', 'l', 'o']

// 展開運算符用於物件（ES2018+）
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };

// 合併物件
const mergedObj = { ...obj1, ...obj2 };
console.log(mergedObj);  // { a: 1, b: 2, c: 3, d: 4 }

// 複製並覆蓋特定屬性
const modified = { ...obj1, b: 3 };
console.log(modified);  // { a: 1, b: 3 }

// 剩餘參數
function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3, 4, 5));  // 15

// 結合普通參數和剩餘參數
function printInfo(title, ...details) {
    console.log(`${title}：`);
    details.forEach(detail => console.log(`- ${detail}`));
}

printInfo('水果', '蘋果', '香蕉', '橙子');
// 水果：
// - 蘋果
// - 香蕉
// - 橙子</textarea>
                <button class="copy-button" onclick="copyCode('code-spread-rest')">複製</button>
            </div>
            
            <h3>12.6 類與繼承</h3>
            <p>ES6引入了類語法，使面向對象編程更加直觀。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-classes-es6" readonly>// ES6類語法
class Person {
    // 構造函數
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    // 實例方法
    sayHello() {
        return `你好，我是${this.name}，${this.age}歲`;
    }
    
    // 獲取器
    get info() {
        return `${this.name}, ${this.age}歲`;
    }
    
    // 設置器
    set info(value) {
        [this.name, this.ageStr] = value.split(',');
        this.age = parseInt(this.ageStr);
    }
    
    // 靜態方法
    static createAnonymous() {
        return new Person('匿名', 0);
    }
}

const person1 = new Person('小明', 30);
console.log(person1.sayHello());  // 你好，我是小明，30歲
console.log(person1.info);  // 小明, 30歲

person1.info = '小華, 25';
console.log(person1.name, person1.age);  // 小華 25

const anonymous = Person.createAnonymous();
console.log(anonymous.name);  // 匿名

// 繼承
class Student extends Person {
    constructor(name, age, grade) {
        // 呼叫父類構造函數
        super(name, age);
        this.grade = grade;
    }
    
    // 覆寫父類方法
    sayHello() {
        return `${super.sayHello()}，我是${this.grade}年級學生`;
    }
    
    study() {
        return `${this.name}正在學習`;
    }
}

const student1 = new Student('小華', 15, '高一');
console.log(student1.sayHello());  // 你好，我是小華，15歲，我是高一年級學生
console.log(student1.study());  // 小華正在學習</textarea>
                <button class="copy-button" onclick="copyCode('code-classes-es6')">複製</button>
            </div>
            
            <h3>12.7 Promise與非同步處理</h3>
            <p>Promise是ES6引入的非同步處理的標準方式，已在前面的章節詳細介紹。</p>
            
            <h3>12.8 模組系統</h3>
            <p>ES6引入了標準化的模組系統，用於代碼組織和重用。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-modules" readonly>// math.js
export const PI = 3.14159;

export function add(a, b) {
    return a + b;
}

export function multiply(a, b) {
    return a * b;
}

export default class Calculator {
    add(a, b) {
        return a + b;
    }
    
    subtract(a, b) {
        return a - b;
    }
}

// 在另一個文件中導入
// main.js
import Calculator, { PI, add, multiply } from './math.js';

console.log(PI);  // 3.14159
console.log(add(2, 3));  // 5

const calc = new Calculator();
console.log(calc.subtract(10, 5));  // 5

// 導入所有導出項為一個物件
import * as MathUtils from './math.js';

console.log(MathUtils.PI);  // 3.14159
console.log(MathUtils.add(4, 5));  // 9

// 動態導入（ES2020）
async function loadModule() {
    const math = await import('./math.js');
    console.log(math.PI);
    return math;
}</textarea>
                <button class="copy-button" onclick="copyCode('code-modules')">複製</button>
            </div>
            
            <h3>12.9 其他ES6+特性</h3>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-other-es6" readonly>// Symbol - 唯一標識符
const id = Symbol('id');
const user = {
    name: '小明',
    [id]: 12345
};
console.log(user[id]);  // 12345

// Map - 鍵值對集合
const userMap = new Map();
userMap.set('name', '小明');
userMap.set('age', 30);
userMap.set(id, 12345);  // 可以使用任何類型作為鍵

console.log(userMap.get('name'));  // 小明
console.log(userMap.has('age'));   // true
console.log(userMap.size);         // 3

// Set - 唯一值的集合
const uniqueNumbers = new Set([1, 2, 3, 3, 4, 4, 5]);
console.log([...uniqueNumbers]);  // [1, 2, 3, 4, 5]

uniqueNumbers.add(6);
console.log(uniqueNumbers.has(3));  // true
console.log(uniqueNumbers.size);    // 6

// 迭代器和生成器
function* idGenerator() {
    let id = 1;
    while (true) {
        yield id++;
    }
}

const ids = idGenerator();
console.log(ids.next().value);  // 1
console.log(ids.next().value);  // 2

// 可選鏈操作符 ?. (ES2020)
const user2 = { 
    name: '小明',
    address: { 
        city: '台北' 
    } 
};

// 傳統方式，需要檢查每一級
const city = user2 && user2.address && user2.address.city;

// 使用可選鏈
const city2 = user2?.address?.city;
console.log(city2);  // 台北

// 空值合併運算符 ?? (ES2020)
const value = null;
const defaultValue = value ?? 'default';
console.log(defaultValue);  // 'default'

// 邏輯賦值運算符 (ES2021)
let x = null;
x ??= 10;  // 等同於 x = x ?? 10
console.log(x);  // 10

let y = 5;
y ??= 10;
console.log(y);  // 仍然是5，因為y不是null或undefined</textarea>
                <button class="copy-button" onclick="copyCode('code-other-es6')">複製</button>
            </div>
        </section>
        
        <section id="modules" class="section">
            <h2>13. 模組系統</h2>
            <h3>13.1 JavaScript模組演進</h3>
            <p>JavaScript模組系統經歷了多種形式的演變：</p>
            
            <ol>
                <li><strong>全局變數與命名空間</strong>：早期的方式，容易造成名稱衝突</li>
                <li><strong>CommonJS</strong>：Node.js使用的模組系統</li>
                <li><strong>AMD (Asynchronous Module Definition)</strong>：用於瀏覽器的異步模組加載</li>
                <li><strong>UMD (Universal Module Definition)</strong>：兼容CommonJS和AMD</li>
                <li><strong>ES Modules</strong>：JavaScript官方標準模組系統</li>
            </ol>
            
            <h3>13.2 ES模組基礎</h3>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-es-modules" readonly>// 在HTML中使用模組
// <script type="module" src="main.js"></script>

// 基本導出和導入
// math.js
export function add(a, b) {
    return a + b;
}

export const PI = 3.14159;

// main.js
import { add, PI } from './math.js';
console.log(add(2, 3));  // 5
console.log(PI);  // 3.14159

// 默認導出和導入
// utils.js
export default function formatDate(date) {
    return date.toLocaleDateString();
}

// main.js
import formatDate from './utils.js';
console.log(formatDate(new Date()));  // 格式化的日期

// 混合默認導出和命名導出
// api.js
export default class API {
    // API類
}

export function get(url) {
    // 獲取數據
}

export function post(url, data) {
    // 發送數據
}

// main.js
import API, { get, post } from './api.js';
const api = new API();
get('/users');

// 重命名導入
import { add as sum, PI as MATH_PI } from './math.js';
console.log(sum(5, 10));  // 15

// 導入所有導出為一個對象
import * as MathUtils from './math.js';
console.log(MathUtils.add(1, 2));  // 3
console.log(MathUtils.PI);  // 3.14159</textarea>
                <button class="copy-button" onclick="copyCode('code-es-modules')">複製</button>
            </div>
            
            <h3>13.3 模組特性</h3>
            <p>ES模組具有以下特性：</p>
            
            <ul>
                <li>模組自動運行在嚴格模式中（'use strict'）</li>
                <li>模組有自己的作用域，不會污染全局作用域</li>
                <li>模組只執行一次，即使被多次導入</li>
                <li>模組支持頂層await（ES2022）</li>
                <li>導入是靜態的，必須位於模組頂層</li>
            </ul>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-module-features" readonly>// 模組具有自己的作用域
// module1.js
const privateVar = 'This is private';
export const publicVar = 'This is public';

// module2.js
import { publicVar } from './module1.js';
console.log(publicVar);  // 'This is public'
// console.log(privateVar);  // Error: privateVar is not defined

// 頂層await（ES2022）
// data-service.js
export async function fetchData() {
    const response = await fetch('https://api.example.com/data');
    return response.json();
}

// 可以在模組頂層使用await
// app.js
const data = await fetchData();
console.log(data);

// 動態導入
// 允許根據條件或在需要時加載模組
async function loadModule() {
    if (condition) {
        const { feature } = await import('./feature.js');
        feature();
    }
}</textarea>
                <button class="copy-button" onclick="copyCode('code-module-features')">複製</button>
            </div>
            
            <h3>13.4 模組最佳實踐</h3>
            
            <div class="example">
                <p>使用模組的最佳實踐：</p>
                <ol>
                    <li>每個文件一個模組，遵循單一職責原則</li>
                    <li>使用明確的導入和導出語句</li>
                    <li>避免副作用，保持模組純淨</li>
                    <li>使用適當的文件擴展名（.js、.mjs）</li>
                    <li>創建索引文件（barrel files）以簡化導入</li>
                </ol>
            </div>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-module-practices" readonly>// 索引文件示例
// 在utils/index.js中集中導出
export { default as formatDate } from './formatDate.js';
export { default as formatCurrency } from './formatCurrency.js';
export { default as validateEmail } from './validateEmail.js';

// 在應用中簡化導入
import { formatDate, formatCurrency, validateEmail } from './utils';

// 組織大型應用的模組
// src/
//   /components/
//     /Button/
//       index.js
//       Button.js
//       Button.css
//     /Modal/
//       index.js
//       Modal.js
//       Modal.css
//   /services/
//     api.js
//     auth.js
//   /utils/
//     index.js
//     format.js
//     validation.js
//   /pages/
//     Home.js
//     About.js
//   index.js  // 應用入口</textarea>
                <button class="copy-button" onclick="copyCode('code-module-practices')">複製</button>
            </div>
        </section>

        <section id="storage" class="section">
            <h2>14. 存儲</h2>
            <h3>14.1 Cookie</h3>
            <p>Cookie是存儲在用戶瀏覽器中的小型文本數據，會在每次HTTP請求中發送到服務器。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-cookies" readonly>// 設置cookie
document.cookie = "username=小明";

// 設置帶過期時間的cookie（10分鐘後過期）
let expiryDate = new Date();
expiryDate.setTime(expiryDate.getTime() + (10 * 60 * 1000));
document.cookie = `username=小明; expires=${expiryDate.toUTCString()}`;

// 設置帶路徑的cookie
document.cookie = "username=小明; path=/";

// 設置安全cookie（只通過HTTPS發送）
document.cookie = "username=小明; secure";

// 設置HttpOnly cookie（JavaScript無法訪問）
// 只能由服務器設置

// 讀取所有cookie
console.log(document.cookie);  // 返回所有非HttpOnly cookie的字符串

// 解析cookie
function getCookie(name) {
    const cookieArr = document.cookie.split(';');
    
    for (let i = 0; i < cookieArr.length; i++) {
        const cookiePair = cookieArr[i].split('=');
        const cookieName = cookiePair[0].trim();
        
        if (cookieName === name) {
            return decodeURIComponent(cookiePair[1]);
        }
    }
    
    return null;
}

// 刪除cookie（通過設置過期時間為過去）
document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";</textarea>
                <button class="copy-button" onclick="copyCode('code-cookies')">複製</button>
            </div>
            
            <h3>14.2 Web Storage (localStorage與sessionStorage)</h3>
            <p>Web Storage API提供了兩種機制來存儲客戶端數據：localStorage和sessionStorage。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-web-storage" readonly>// localStorage - 永久存儲，除非手動清除
// 設置數據
localStorage.setItem('username', '小明');
localStorage.setItem('preferences', JSON.stringify({
    theme: 'dark',
    fontSize: 'large'
}));

// 獲取數據
const username = localStorage.getItem('username');
const preferences = JSON.parse(localStorage.getItem('preferences'));

console.log(username);  // 小明
console.log(preferences.theme);  // dark

// 刪除特定項目
localStorage.removeItem('username');

// 清除所有數據
localStorage.clear();

// 獲取存儲項數
console.log(localStorage.length);

// 遍歷所有項目
for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    const value = localStorage.getItem(key);
    console.log(`${key}: ${value}`);
}

// sessionStorage - 僅在當前會話期間有效
// 用法與localStorage相同
sessionStorage.setItem('tempData', '暫時數據');
const tempData = sessionStorage.getItem('tempData');
sessionStorage.removeItem('tempData');
sessionStorage.clear();</textarea>
                <button class="copy-button" onclick="copyCode('code-web-storage')">複製</button>
            </div>
            
            <h3>14.3 IndexedDB</h3>
            <p>IndexedDB是一個低級API，用於客戶端存儲大量結構化數據，包括文件和二進制數據。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-indexeddb" readonly>// 打開數據庫
const dbRequest = indexedDB.open('MyDatabase', 1);

// 處理數據庫升級（首次創建或版本更新時）
dbRequest.onupgradeneeded = function(event) {
    const db = event.target.result;
    
    // 創建對象倉庫（類似表）
    const usersStore = db.createObjectStore('users', { keyPath: 'id' });
    
    // 創建索引
    usersStore.createIndex('name', 'name', { unique: false });
    usersStore.createIndex('email', 'email', { unique: true });
    
    console.log('數據庫設置完成');
};

// 連接成功
dbRequest.onsuccess = function(event) {
    const db = event.target.result;
    console.log('數據庫連接成功');
    
    // 添加數據
    function addUser(user) {
        const transaction = db.transaction(['users'], 'readwrite');
        const usersStore = transaction.objectStore('users');
        const request = usersStore.add(user);
        
        request.onsuccess = function() {
            console.log('用戶添加成功');
        };
        
        request.onerror = function() {
            console.error('添加用戶出錯');
        };
    }
    
    // 獲取數據
    function getUser(id) {
        const transaction = db.transaction(['users']);
        const usersStore = transaction.objectStore('users');
        const request = usersStore.get(id);
        
        request.onsuccess = function() {
            console.log('獲取的用戶:', request.result);
        };
    }
    
    // 更新數據
    function updateUser(user) {
        const transaction = db.transaction(['users'], 'readwrite');
        const usersStore = transaction.objectStore('users');
        const request = usersStore.put(user);
        
        request.onsuccess = function() {
            console.log('用戶更新成功');
        };
    }
    
    // 刪除數據
    function deleteUser(id) {
        const transaction = db.transaction(['users'], 'readwrite');
        const usersStore = transaction.objectStore('users');
        const request = usersStore.delete(id);
        
        request.onsuccess = function() {
            console.log('用戶刪除成功');
        };
    }
    
    // 使用索引查詢
    function getUserByEmail(email) {
        const transaction = db.transaction(['users']);
        const usersStore = transaction.objectStore('users');
        const emailIndex = usersStore.index('email');
        const request = emailIndex.get(email);
        
        request.onsuccess = function() {
            console.log('通過電子郵件找到的用戶:', request.result);
        };
    }
    
    // 使用游標遍歷所有記錄
    function getAllUsers() {
        const users = [];
        const transaction = db.transaction(['users']);
        const usersStore = transaction.objectStore('users');
        const request = usersStore.openCursor();
        
        request.onsuccess = function(event) {
            const cursor = event.target.result;
            if (cursor) {
                users.push(cursor.value);
                cursor.continue();
            } else {
                console.log('所有用戶:', users);
            }
        };
    }
    
    // 添加示例用戶
    addUser({ id: 1, name: '小明', email: 'xiaoming@example.com', age: 30 });
};

// 連接失敗
dbRequest.onerror = function(event) {
    console.error('數據庫連接出錯:', event.target.error);
};</textarea>
                <button class="copy-button" onclick="copyCode('code-indexeddb')">複製</button>
            </div>
            
            <h3>14.4 存儲選擇指南</h3>
            
            <table>
                <tr>
                    <th>存儲類型</th>
                    <th>最大容量</th>
                    <th>生命週期</th>
                    <th>適用場景</th>
                </tr>
                <tr>
                    <td>Cookie</td>
                    <td>4KB</td>
                    <td>可設置過期時間</td>
                    <td>儲存身份驗證信息，服務器需要讀取的數據</td>
                </tr>
                <tr>
                    <td>localStorage</td>
                    <td>5-10MB</td>
                    <td>永久，直到被清除</td>
                    <td>持久的用戶偏好設置，主題，非敏感數據緩存</td>
                </tr>
                <tr>
                    <td>sessionStorage</td>
                    <td>5-10MB</td>
                    <td>頁面會話期間</td>
                    <td>表單數據暫存，一次性會話數據</td>
                </tr>
                <tr>
                    <td>IndexedDB</td>
                    <td>無限制(取決於磁盤空間)</td>
                    <td>永久，直到被清除</td>
                    <td>大型結構化數據，離線應用，文件/圖像緩存</td>
                </tr>
            </table>
            
            <div class="example">
                <p>存儲安全注意事項：</p>
                <ul>
                    <li>永遠不要在客戶端存儲敏感信息（如密碼、信用卡號）</li>
                    <li>Cookie使用HttpOnly和Secure標記增強安全性</li>
                    <li>實施內容安全策略(CSP)防止XSS攻擊</li>
                    <li>考慮加密存儲的數據</li>
                    <li>遵守數據隱私法規(GDPR, CCPA等)，獲取用戶同意</li>
                </ul>
            </div>
        </section>

        <section id="json" class="section">
            <h2>15. JSON操作</h2>
            <h3>15.1 什麼是JSON？</h3>
            <p>JSON (JavaScript Object Notation) 是一種輕量級的數據交換格式，易於人閱讀和編寫，也易於機器解析和生成。</p>
            
            <div class="example">
                <p>JSON的基本規則：</p>
                <ul>
                    <li>數據以名稱/值對表示</li>
                    <li>使用大括號 {} 保存對象</li>
                    <li>使用方括號 [] 保存數組</li>
                    <li>名稱必須使用雙引號包裹</li>
                    <li>值可以是字符串、數字、對象、數組、布爾值或null</li>
                    <li>不支持註釋、undefined、函數和日期對象</li>
                </ul>
            </div>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-json-example" readonly>// JSON對象示例
const personJSON = `{
    "name": "小明",
    "age": 30,
    "isStudent": false,
    "hobbies": ["閱讀", "游泳", "編程"],
    "address": {
        "city": "台北",
        "zipCode": "100"
    },
    "phone": null
}`;

// JSON數組示例
const arrayJSON = `[
    {
        "id": 1,
        "name": "小明"
    },
    {
        "id": 2,
        "name": "小華"
    },
    {
        "id": 3,
        "name": "小李"
    }
]`;</textarea>
                <button class="copy-button" onclick="copyCode('code-json-example')">複製</button>
            </div>
            
            <h3>15.2 JSON.parse() - 解析JSON</h3>
            <p>將JSON字符串轉換為JavaScript對象或數組。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-json-parse" readonly>// 基本解析
const jsonString = '{"name":"小明","age":30}';
const person = JSON.parse(jsonString);

console.log(person.name);  // 小明
console.log(person.age);   // 30

// 解析數組
const jsonArray = '[1,2,3,4,5]';
const numbers = JSON.parse(jsonArray);
console.log(numbers[2]);  // 3

// 解析嵌套對象
const complexJson = '{"user":{"name":"小明","profile":{"age":30,"city":"台北"}}}';
const data = JSON.parse(complexJson);
console.log(data.user.profile.city);  // 台北

// 使用第二個參數（reviver函數）
const jsonWithDate = '{"name":"小明","birthDate":"2000-01-15"}';
const personWithDate = JSON.parse(jsonWithDate, (key, value) => {
    // 自動將日期字符串轉換為Date對象
    if (key === 'birthDate') {
        return new Date(value);
    }
    return value;
});

console.log(personWithDate.birthDate.getFullYear());  // 2000

// 處理JSON.parse錯誤
try {
    const invalidJson = '{"name":"小明",}';  // 無效的JSON（多餘的逗號）
    const parsed = JSON.parse(invalidJson);
} catch (error) {
    console.error('JSON解析錯誤:', error.message);
}</textarea>
                <button class="copy-button" onclick="copyCode('code-json-parse')">複製</button>
            </div>
            
            <h3>15.3 JSON.stringify() - 序列化為JSON</h3>
            <p>將JavaScript對象或數組轉換為JSON字符串。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-json-stringify" readonly>// 基本序列化
const person = {
    name: '小明',
    age: 30,
    isStudent: false
};
const jsonString = JSON.stringify(person);
console.log(jsonString);  // {"name":"小明","age":30,"isStudent":false}

// 序列化數組
const colors = ['紅', '綠', '藍'];
const jsonArray = JSON.stringify(colors);
console.log(jsonArray);  // ["紅","綠","藍"]

// 美化輸出（格式化）
const prettyJson = JSON.stringify(person, null, 2);
console.log(prettyJson);
/*
{
  "name": "小明",
  "age": 30,
  "isStudent": false
}
*/

// 使用第二個參數（replacer函數）
const personWithPrivate = {
    name: '小明',
    age: 30,
    password: '12345',
    _internal: 'some value'
};

// 過濾掉私有屬性
const filteredJson = JSON.stringify(personWithPrivate, (key, value) => {
    if (key.startsWith('_') || key === 'password') {
        return undefined;  // 排除此屬性
    }
    return value;
});

console.log(filteredJson);  // {"name":"小明","age":30}

// 使用第二個參數（replacer數組）
const selectedJson = JSON.stringify(person, ['name']);
console.log(selectedJson);  // {"name":"小明"}

// 處理特殊值
const specialValues = {
    undef: undefined,        // 會被忽略
    func: function() {},     // 會被忽略
    sym: Symbol('symbol'),   // 會被忽略
    inf: Infinity,           // 轉換為null
    nan: NaN,                // 轉換為null
    date: new Date()         // 轉換為ISO日期字符串
};

console.log(JSON.stringify(specialValues));
// {"inf":null,"nan":null,"date":"2023-05-15T12:00:00.000Z"}

// 使用toJSON方法自定義序列化
const customObject = {
    name: '小明',
    birthDate: new Date(2000, 0, 15),
    toJSON: function() {
        return {
            name: this.name,
            birthYear: this.birthDate.getFullYear()
        };
    }
};

console.log(JSON.stringify(customObject));  // {"name":"小明","birthYear":2000}</textarea>
                <button class="copy-button" onclick="copyCode('code-json-stringify')">複製</button>
            </div>
            
            <h3>15.4 JSON的常見用途</h3>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-json-usage" readonly>// 1. 數據存儲 - localStorage
const userPreferences = {
    theme: 'dark',
    fontSize: 'large',
    notifications: true
};

// 保存到localStorage
localStorage.setItem('preferences', JSON.stringify(userPreferences));

// 讀取並解析
const savedPreferences = JSON.parse(localStorage.getItem('preferences'));

// 2. 深拷貝對象
const original = { 
    name: '小明', 
    profile: { age: 30, city: '台北' } 
};

// 創建深拷貝（處理嵌套對象）
const deepCopy = JSON.parse(JSON.stringify(original));
deepCopy.profile.city = '高雄';  // 不會影響原對象

console.log(original.profile.city);  // 台北
console.log(deepCopy.profile.city);  // 高雄

// 3. 使用fetch API發送和接收JSON數據
fetch('https://api.example.com/data')
    .then(response => response.json())  // 解析JSON響應
    .then(data => console.log(data))
    .catch(error => console.error('Error:', error));

// 發送JSON數據
fetch('https://api.example.com/users', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({ name: '小明', email: 'xiaoming@example.com' })
})
    .then(response => response.json())
    .then(data => console.log('Success:', data))
    .catch(error => console.error('Error:', error));</textarea>
                <button class="copy-button" onclick="copyCode('code-json-usage')">複製</button>
            </div>
        </section>
        
        <section id="api" class="section">
            <h2>16. API請求</h2>
            <h3>16.1 什麼是Web API？</h3>
            <p>Web API (Application Programming Interface) 是允許不同軟件系統之間通信的接口。在Web開發中，API通常以HTTP請求的形式提供數據或功能。</p>
            
            <div class="example">
                <p>常見的API類型：</p>
                <ul>
                    <li><strong>REST API</strong>：使用HTTP方法操作資源的架構風格</li>
                    <li><strong>GraphQL</strong>：允許客戶端指定所需數據的查詢語言</li>
                    <li><strong>WebSocket API</strong>：提供雙向實時通信</li>
                    <li><strong>瀏覽器API</strong>：例如地理位置、Web存儲、Canvas等</li>
                </ul>
            </div>
            
            <h3>16.2 XMLHttpRequest</h3>
            <p>XMLHttpRequest是早期發送HTTP請求的方法，現在大多被fetch API替代。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-xhr" readonly>// 創建一個XMLHttpRequest對象
const xhr = new XMLHttpRequest();

// 配置請求
xhr.open('GET', 'https://jsonplaceholder.typicode.com/users/1', true);

// 設置響應類型
xhr.responseType = 'json';

// 處理響應
xhr.onload = function() {
    if (xhr.status >= 200 && xhr.status < 300) {
        // 請求成功
        console.log('數據：', xhr.response);
    } else {
        // 請求失敗
        console.error('請求失敗：', xhr.statusText);
    }
};

// 處理錯誤
xhr.onerror = function() {
    console.error('網絡錯誤');
};

// 發送請求
xhr.send();

// 發送POST請求
function postData() {
    const xhr = new XMLHttpRequest();
    xhr.open('POST', 'https://jsonplaceholder.typicode.com/posts', true);
    xhr.setRequestHeader('Content-Type', 'application/json');
    
    xhr.onload = function() {
        if (xhr.status >= 200 && xhr.status < 300) {
            console.log('發送成功：', xhr.response);
        } else {
            console.error('請求失敗');
        }
    };
    
    // 發送JSON數據
    const data = JSON.stringify({
        title: '標題',
        body: '內容',
        userId: 1
    });
    
    xhr.send(data);
}</textarea>
                <button class="copy-button" onclick="copyCode('code-xhr')">複製</button>
            </div>
            
            <h3>16.3 Fetch API</h3>
            <p>Fetch API是現代JavaScript處理HTTP請求的標準方式，它使用Promise，更簡潔和靈活。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-fetch-api" readonly>// 基本GET請求
fetch('https://jsonplaceholder.typicode.com/users/1')
    .then(response => {
        // 檢查響應狀態
        if (!response.ok) {
            throw new Error('網絡響應不正常: ' + response.status);
        }
        return response.json();  // 解析JSON響應
    })
    .then(data => {
        console.log('用戶數據：', data);
    })
    .catch(error => {
        console.error('獲取數據出錯：', error);
    });

// POST請求
fetch('https://jsonplaceholder.typicode.com/posts', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({
        title: '標題',
        body: '內容',
        userId: 1
    })
})
    .then(response => response.json())
    .then(data => {
        console.log('創建的帖子：', data);
    })
    .catch(error => {
        console.error('錯誤：', error);
    });

// 使用async/await簡化
async function fetchData() {
    try {
        const response = await fetch('https://jsonplaceholder.typicode.com/users/1');
        
        if (!response.ok) {
            throw new Error('網絡響應不正常: ' + response.status);
        }
        
        const data = await response.json();
        console.log('用戶數據：', data);
        return data;
    } catch (error) {
        console.error('獲取數據出錯：', error);
    }
}

// 其他HTTP方法
async function updatePost(id, data) {
    try {
        const response = await fetch(`https://jsonplaceholder.typicode.com/posts/${id}`, {
            method: 'PUT',  // 或 'PATCH' 進行部分更新
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) throw new Error('更新失敗');
        
        return await response.json();
    } catch (error) {
        console.error('更新錯誤：', error);
    }
}

async function deletePost(id) {
    try {
        const response = await fetch(`https://jsonplaceholder.typicode.com/posts/${id}`, {
            method: 'DELETE'
        });
        
        if (!response.ok) throw new Error('刪除失敗');
        
        return response.status === 204 ? true : await response.json();
    } catch (error) {
        console.error('刪除錯誤：', error);
    }
}</textarea>
                <button class="copy-button" onclick="copyCode('code-fetch-api')">複製</button>
            </div>
            
            <h3>16.4 Fetch API的高級特性</h3>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-fetch-advanced" readonly>// 設置請求超時
async function fetchWithTimeout(url, options = {}, timeout = 5000) {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);
    
    try {
        const response = await fetch(url, {
            ...options,
            signal: controller.signal
        });
        clearTimeout(id);
        return response;
    } catch (error) {
        clearTimeout(id);
        if (error.name === 'AbortError') {
            throw new Error('請求超時');
        }
        throw error;
    }
}

// 發送表單數據
async function submitForm(formData) {
    try {
        const response = await fetch('https://example.com/submit', {
            method: 'POST',
            body: formData  // FormData對象直接發送
        });
        return await response.json();
    } catch (error) {
        console.error('表單提交錯誤：', error);
    }
}

// 上傳文件
async function uploadFile(file) {
    const formData = new FormData();
    formData.append('file', file);
    
    try {
        const response = await fetch('https://example.com/upload', {
            method: 'POST',
            body: formData
        });
        return await response.json();
    } catch (error) {
        console.error('文件上傳錯誤：', error);
    }
}

// 讀取二進制數據
async function fetchImage() {
    try {
        const response = await fetch('https://example.com/image.jpg');
        const blob = await response.blob();
        
        // 創建一個URL對象
        const imageUrl = URL.createObjectURL(blob);
        
        // 顯示圖像
        const img = document.createElement('img');
        img.src = imageUrl;
        document.body.appendChild(img);
        
        // 使用完畢後釋放URL
        setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
    } catch (error) {
        console.error('獲取圖像錯誤：', error);
    }
}</textarea>
                <button class="copy-button" onclick="copyCode('code-fetch-advanced')">複製</button>
            </div>
            
            <h3>16.5 跨域資源共享 (CORS)</h3>
            <p>CORS是一種HTTP頭部機制，允許服務器指定哪些其他域可以訪問其資源。</p>
            
            <div class="example">
                <p>CORS請求類型：</p>
                <ol>
                    <li><strong>簡單請求</strong>：基本GET、HEAD或POST請求，只使用標準頭部</li>
                    <li><strong>預檢請求</strong>：發送OPTIONS請求檢查服務器是否允許實際請求</li>
                </ol>
            </div>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-cors" readonly>// 簡單的跨域請求
fetch('https://api.another-domain.com/data')
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error('跨域請求失敗：', error));

// 包含自定義頭部的跨域請求（會觸發預檢請求）
fetch('https://api.another-domain.com/data', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'X-Custom-Header': 'value'  // 自定義頭部
    },
    body: JSON.stringify({ key: 'value' })
})
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error('跨域請求失敗：', error));

// 跨域請求攜帶憑證（cookies）
fetch('https://api.another-domain.com/data', {
    credentials: 'include'  // 發送cookies等憑證
})
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error('跨域請求失敗：', error));</textarea>
                <button class="copy-button" onclick="copyCode('code-cors')">複製</button>
            </div>
            
            <h3>16.6 API請求最佳實踐</h3>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-api-best-practices" readonly>// 1. 創建API服務模塊
// api.js
const API_BASE_URL = 'https://api.example.com';

// 通用請求函數
async function request(endpoint, options = {}) {
    const url = `${API_BASE_URL}${endpoint}`;
    
    // 合併默認選項
    const fetchOptions = {
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${getAuthToken()}`
        },
        ...options
    };
    
    try {
        const response = await fetch(url, fetchOptions);
        
        // 處理HTTP錯誤
        if (!response.ok) {
            const error = await response.json().catch(() => ({}));
            throw new Error(error.message || `HTTP error! Status: ${response.status}`);
        }
        
        // 處理空響應
        if (response.status === 204) {
            return null;
        }
        
        // 解析JSON響應
        return await response.json();
    } catch (error) {
        // 處理網絡錯誤、解析錯誤等
        console.error(`API請求失敗 (${endpoint}):`, error);
        throw error;
    }
}

// 各種API端點
const api = {
    // 用戶相關
    users: {
        getAll: () => request('/users'),
        getById: (id) => request(`/users/${id}`),
        create: (data) => request('/users', { 
            method: 'POST',
            body: JSON.stringify(data)
        }),
        update: (id, data) => request(`/users/${id}`, { 
            method: 'PUT',
            body: JSON.stringify(data)
        }),
        delete: (id) => request(`/users/${id}`, { method: 'DELETE' })
    },
    
    // 認證相關
    auth: {
        login: (credentials) => request('/auth/login', { 
            method: 'POST',
            body: JSON.stringify(credentials)
        }),
        logout: () => request('/auth/logout', { method: 'POST' })
    }
};

// 2. 實現重試機制
async function fetchWithRetry(url, options = {}, retries = 3) {
    try {
        return await fetch(url, options);
    } catch (error) {
        if (retries <= 1) throw error;
        
        // 等待一段時間後重試
        await new Promise(resolve => setTimeout(resolve, 1000));
        return fetchWithRetry(url, options, retries - 1);
    }
}

// 3. 緩存請求結果
const cache = new Map();

async function fetchWithCache(url, options = {}, cacheTime = 60000) {
    const cacheKey = `${url}-${JSON.stringify(options)}`;
    
    // 檢查緩存是否有效
    if (cache.has(cacheKey)) {
        const cachedData = cache.get(cacheKey);
        if (Date.now() - cachedData.timestamp < cacheTime) {
            return cachedData.data;
        }
    }
    
    // 發送實際請求
    const response = await fetch(url, options);
    const data = await response.json();
    
    // 更新緩存
    cache.set(cacheKey, {
        data,
        timestamp: Date.now()
    });
    
    return data;
}</textarea>
                <button class="copy-button" onclick="copyCode('code-api-best-practices')">複製</button>
            </div>
        </section>
        
        <section id="debugging" class="section">
            <h2>17. 調試技巧</h2>
            <h3>17.1 瀏覽器開發者工具</h3>
            <p>現代瀏覽器內置的開發者工具是JavaScript調試的最強大工具之一。</p>
            
            <div class="example">
                <p>開啟開發者工具的方法：</p>
                <ul>
                    <li>Chrome/Edge：按 F12 或 Ctrl+Shift+I (Windows) / Cmd+Option+I (Mac)</li>
                    <li>Firefox：按 F12 或 Ctrl+Shift+I (Windows) / Cmd+Option+I (Mac)</li>
                    <li>Safari：開啟"開發"菜單，然後選擇"顯示Web檢查器"</li>
                </ul>
            </div>
            
            <h4>17.1.1 控制台面板 (Console)</h4>
            <div class="runnable-code">
                <textarea class="code-editor" id="code-console" readonly>// 基本日誌輸出
console.log('基本信息');
console.info('信息消息');
console.warn('警告消息');
console.error('錯誤消息');

// 對象和陣列的輸出
let person = { name: '小明', age: 30 };
console.log('用戶信息:', person);

let numbers = [1, 2, 3, 4, 5];
console.table(numbers);  // 以表格形式顯示

// 分組輸出
console.group('用戶詳情');
console.log('姓名: 小明');
console.log('年齡: 30');
console.groupEnd();

// 計時操作
console.time('操作');
// ... 進行一些操作
console.timeEnd('操作');  // 輸出操作耗時

// 計數
for (let i = 0; i < 5; i++) {
    console.count('循環計數');
}

// 條件日誌
console.assert(1 === 2, '斷言失敗');  // 只在條件為false時輸出

// 清空控制台
console.clear();</textarea>
                <button class="copy-button" onclick="copyCode('code-console')">複製</button>
            </div>
            
            <h4>17.1.2 斷點調試</h4>
            <p>使用斷點可以暫停代碼執行，逐行檢查變數狀態和程序流程。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-breakpoints" readonly>// 方法1：在開發者工具Sources面板中點擊行號設置斷點

// 方法2：使用debugger語句（程式碼斷點）
function calculateTotal(items) {
    debugger;  // 程序將在此處暫停執行
    let total = 0;
    for (let i = 0; i < items.length; i++) {
        total += items[i].price;
    }
    return total;
}

// 方法3：條件斷點
// 在Sources面板中右鍵點擊行號，選擇"Add conditional breakpoint"
// 例如設置條件： i === 5

// 方法4：DOM變化斷點
// 在Elements面板中右鍵點擊元素，選擇"Break on..."</textarea>
                <button class="copy-button" onclick="copyCode('code-breakpoints')">複製</button>
            </div>
            
            <h3>17.2 常見調試技巧</h3>
            
            <h4>17.2.1 調試錯誤堆疊</h4>
            <div class="runnable-code">
                <textarea class="code-editor" id="code-error-stack" readonly>// 捕獲並分析錯誤堆疊
try {
    // 故意製造一個錯誤
    let obj = null;
    obj.someProperty = 42;
} catch (error) {
    console.error('錯誤信息:', error.message);
    console.error('錯誤堆疊:', error.stack);
    // 堆疊跟蹤顯示了錯誤發生的位置和呼叫順序
}</textarea>
                <button class="copy-button" onclick="copyCode('code-error-stack')">複製</button>
            </div>
            
            <h4>17.2.2 使用try-catch進行調試</h4>
            <div class="runnable-code">
                <textarea class="code-editor" id="code-debug-trycatch" readonly>// 使用try-catch進行定位錯誤
function processUserData(userData) {
    try {
        console.log('處理用戶數據...');
        validateUser(userData);
        updateUserProfile(userData);
        notifyUser(userData.id);
        return true;
    } catch (error) {
        console.error('處理用戶數據時出錯:', error.message);
        console.error('堆疊:', error.stack);
        // 可以根據錯誤類型或消息進行不同處理
        return false;
    }
}</textarea>
                <button class="copy-button" onclick="copyCode('code-debug-trycatch')">複製</button>
            </div>
            
            <h3>17.3 高級調試技巧</h3>
            
            <h4>17.3.1 監控變數</h4>
            <div class="runnable-code">
                <textarea class="code-editor" id="code-monitor-variables" readonly>// 1. 使用 console.log 跟踪變數
function calculateArea(width, height) {
    console.log(`初始值 - 寬度: ${width}, 高度: ${height}`);
    
    width = Math.abs(width);
    height = Math.abs(height);
    console.log(`絕對值轉換後 - 寬度: ${width}, 高度: ${height}`);
    
    const area = width * height;
    console.log(`計算結果 - 面積: ${area}`);
    
    return area;
}

// 2. 在Sources面板中使用Watch表達式
// 在調試時添加表達式如 width, height, width*height

// 3. 使用 Object.observe (已棄用) 或 Proxy 監視對象變化
const user = { name: '小明', score: 0 };

const userProxy = new Proxy(user, {
    set(target, property, value) {
        console.log(`${property} 從 ${target[property]} 變更為 ${value}`);
        target[property] = value;
        return true;
    }
});

userProxy.score = 100;  // 輸出: "score 從 0 變更為 100"</textarea>
                <button class="copy-button" onclick="copyCode('code-monitor-variables')">複製</button>
            </div>
            
            <h4>17.3.2 性能分析</h4>
            <div class="runnable-code">
                <textarea class="code-editor" id="code-performance" readonly>// 使用 Performance API 測量代碼執行時間
function measurePerformance() {
    performance.mark('startTask');
    
    // 執行需要測量的代碼
    for (let i = 0; i < 1000000; i++) {
        Math.sqrt(i);
    }
    
    performance.mark('endTask');
    performance.measure('taskDuration', 'startTask', 'endTask');
    
    const measures = performance.getEntriesByName('taskDuration');
    console.log(`任務耗時: ${measures[0].duration} 毫秒`);
    
    // 清除標記
    performance.clearMarks();
    performance.clearMeasures();
}

// 使用 console.time/timeEnd 測量
function simplePerformanceMeasure() {
    console.time('循環操作');
    
    for (let i = 0; i < 1000000; i++) {
        Math.sqrt(i);
    }
    
    console.timeEnd('循環操作');
}

// 使用Chrome開發者工具的Performance面板記錄更詳細的性能分析</textarea>
                <button class="copy-button" onclick="copyCode('code-performance')">複製</button>
            </div>
            
            <h3>17.4 遠程調試</h3>
            <p>遠程調試允許你在一個設備上調試在另一個設備上運行的代碼。</p>
            
            <div class="example">
                <p>遠程調試步驟：</p>
                <ol>
                    <li>Chrome遠程調試Android：連接Android設備，開啟開發者選項，訪問chrome://inspect</li>
                    <li>Safari遠程調試iOS：連接iOS設備，開啟開發者菜單，選擇連接的設備</li>
                    <li>VS Code和Chrome進行調試：使用Chrome Debugger擴展</li>
                </ol>
            </div>
            
            <h3>17.5 日誌和調試最佳實踐</h3>
            
            <div class="example">
                <p>有效的調試實踐：</p>
                <ul>
                    <li>使用描述性的日誌消息：清晰標示日誌點的位置和目的</li>
                    <li>分級日誌：使用不同級別（log, info, warn, error）標示重要性</li>
                    <li>避免在生產環境留下調試代碼：使用條件日誌或構建工具移除</li>
                    <li>使用結構化日誌：包含時間戳、上下文信息等</li>
                    <li>考慮使用專業的日誌庫：如winston(Node.js)、loglevel(瀏覽器)</li>
                </ul>
            </div>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-logging-practices" readonly>// 創建一個簡單的日誌工具
const Logger = {
    level: 'info', // debug, info, warn, error
    
    levels: {
        debug: 0,
        info: 1,
        warn: 2,
        error: 3
    },
    
    debug(message, ...args) {
        if (this.levels[this.level] <= this.levels.debug) {
            console.debug(`[DEBUG][${new Date().toISOString()}]`, message, ...args);
        }
    },
    
    info(message, ...args) {
        if (this.levels[this.level] <= this.levels.info) {
            console.info(`[INFO][${new Date().toISOString()}]`, message, ...args);
        }
    },
    
    warn(message, ...args) {
        if (this.levels[this.level] <= this.levels.warn) {
            console.warn(`[WARN][${new Date().toISOString()}]`, message, ...args);
        }
    },
    
    error(message, ...args) {
        if (this.levels[this.level] <= this.levels.error) {
            console.error(`[ERROR][${new Date().toISOString()}]`, message, ...args);
        }
    },
    
    // 生產環境設置
    setProduction() {
        this.level = 'error';  // 在生產環境只顯示錯誤
    }
};

// 使用示例
Logger.debug('這是調試信息');
Logger.info('用戶已登入', { userId: 123 });
Logger.warn('API請求超時，重試中...');
Logger.error('無法連接到數據庫', { dbName: 'users', errorCode: 500 });

// 在生產環境
if (process.env.NODE_ENV === 'production') {
    Logger.setProduction();
}</textarea>
                <button class="copy-button" onclick="copyCode('code-logging-practices')">複製</button>
            </div>
        </section>

        <section id="best-practices" class="section">
            <h2>18. 最佳實踐</h2>
            <h3>18.1 代碼風格與規範</h3>
            <p>良好的代碼風格提高可讀性和可維護性，減少錯誤。</p>
            
            <div class="example">
                <p>JavaScript風格指南：</p>
                <ul>
                    <li>Airbnb JavaScript風格指南</li>
                    <li>Google JavaScript風格指南</li>
                    <li>StandardJS</li>
                </ul>
            </div>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-style-guide" readonly>// 1. 使用一致的命名約定
// 駝峰命名法（camelCase）用於變數和函數
let userName = 'xiaoming';
function calculateTotal() { }

// 帕斯卡命名法（PascalCase）用於類和構造函數
class UserProfile { }
function Person(name) { }

// 全大寫用於常量
const MAX_SIZE = 100;
const API_KEY = 'abc123';

// 2. 使用有意義的變數和函數名
// 不好的例子
let a = 5;
function fn(x, y) {
    return x + y;
}

// 好的例子
let userAge = 5;
function calculateSum(firstNumber, secondNumber) {
    return firstNumber + secondNumber;
}

// 3. 保持函數簡短，專注於單一職責
// 不好的例子：函數做太多事情
function processUser(user) {
    validateUser(user);
    updateUserInDatabase(user);
    sendEmail(user.email);
    updateUIWithUserData(user);
}

// 好的例子：分解為小函數
function processUser(user) {
    if (validateUser(user)) {
        const updatedUser = updateUserInDatabase(user);
        notifyUserChanges(updatedUser);
        return updatedUser;
    }
    return null;
}

// 4. 適當使用註釋
// 解釋為什麼，而不是解釋什麼
// 不好的例子
// 將年齡加1
age += 1;

// 好的例子
// 每年更新用戶年齡以符合生日後的實際年齡
age += 1;</textarea>
                <button class="copy-button" onclick="copyCode('code-style-guide')">複製</button>
            </div>
            
            <h3>18.2 性能優化</h3>
            <p>JavaScript性能優化有助於創建反應靈敏的用戶體驗。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-performance-tips" readonly>// 1. 減少DOM操作
// 不好的例子：頻繁操作DOM
for (let i = 0; i < 100; i++) {
    document.getElementById('container').innerHTML += `<div>${i}</div>`;
}

// 好的例子：批量操作DOM
let content = '';
for (let i = 0; i < 100; i++) {
    content += `<div>${i}</div>`;
}
document.getElementById('container').innerHTML = content;

// 更好的例子：使用DocumentFragment
const fragment = document.createDocumentFragment();
for (let i = 0; i < 100; i++) {
    const div = document.createElement('div');
    div.textContent = i;
    fragment.appendChild(div);
}
document.getElementById('container').appendChild(fragment);

// 2. 避免內存洩漏
// 不好的例子：創建閉包但不釋放
function createButtons() {
    let count = 0;
    
    document.getElementById('button').addEventListener('click', function() {
        console.log(++count);
    });
}

// 好的例子：清理事件監聽器
function setupButton() {
    let count = 0;
    const button = document.getElementById('button');
    
    function handleClick() {
        console.log(++count);
    }
    
    button.addEventListener('click', handleClick);
    
    // 提供清理方法
    return function cleanup() {
        button.removeEventListener('click', handleClick);
    };
}

// 3. 優化循環
// 不好的例子
const arr = [1, 2, 3, 4, 5];
for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
}

// 好的例子：緩存長度
const arr2 = [1, 2, 3, 4, 5];
for (let i = 0, len = arr2.length; i < len; i++) {
    console.log(arr2[i]);
}

// 4. 使用適當的數據結構
// 頻繁查找：使用Object或Map而不是Array
const userMap = new Map();
userMap.set('user1', { name: '小明', age: 30 });
userMap.set('user2', { name: '小華', age: 25 });

// 快速查找
const user = userMap.get('user1');</textarea>
                <button class="copy-button" onclick="copyCode('code-performance-tips')">複製</button>
            </div>
            
            <h3>18.3 安全最佳實踐</h3>
            <p>Web應用的安全性至關重要，可以防止常見的攻擊。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-security" readonly>// 1. 防止XSS（跨站腳本攻擊）
// 不安全的例子
function displayUserInput(input) {
    document.getElementById('output').innerHTML = input;
}

// 安全的例子：HTML轉義
function displayUserInputSafely(input) {
    const escaped = input
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    
    document.getElementById('output').innerHTML = escaped;
}

// 更好的方法：使用textContent而不是innerHTML
function displayUserInputTextContent(input) {
    document.getElementById('output').textContent = input;
}

// 2. 防止原型污染
// 不安全的例子
function mergeOptions(options) {
    const defaults = { mode: 'dark', fontSize: 16 };
    for (const key in options) {
        defaults[key] = options[key];
    }
    return defaults;
}

// 安全的例子：檢查自有屬性
function mergeOptionsSafely(options) {
    const defaults = { mode: 'dark', fontSize: 16 };
    for (const key in options) {
        if (Object.prototype.hasOwnProperty.call(options, key)) {
            defaults[key] = options[key];
        }
    }
    return defaults;
}

// 更安全的例子：使用Object.assign或展開運算符
function mergeOptionsModern(options) {
    const defaults = { mode: 'dark', fontSize: 16 };
    return { ...defaults, ...options };
}

// 3. 安全地處理JSON數據
function parseJSON(jsonString) {
    try {
        return JSON.parse(jsonString);
    } catch (e) {
        console.error('Invalid JSON:', e);
        return null;
    }
}

// 4. 避免eval和類似函數
// 不安全的例子
function calculateFromUserInput(input) {
    return eval(input);  // 非常危險！
}

// 安全的例子：使用專用解析器或限制輸入
function calculateSafely(input) {
    // 使用正則表達式只允許數字和基本運算符
    if (/^[0-9+\-*/().]+$/.test(input)) {
        // 使用Function比eval稍安全，但仍需謹慎
        return new Function('return ' + input)();
    }
    throw new Error('Invalid input');
}</textarea>
                <button class="copy-button" onclick="copyCode('code-security')">複製</button>
            </div>
            
            <h3>18.4 代碼組織與模塊化</h3>
            <p>良好的代碼組織使代碼更易於理解、測試和維護。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-organization" readonly>// 1. 模塊模式（閉包）
const userModule = (function() {
    // 私有變數和函數
    let userCount = 0;
    const users = [];
    
    function validateUser(user) {
        return user.name && user.email;
    }
    
    // 公開的API
    return {
        addUser: function(user) {
            if (validateUser(user)) {
                users.push(user);
                userCount++;
                return true;
            }
            return false;
        },
        
        getUserCount: function() {
            return userCount;
        },
        
        getUsers: function() {
            return [...users]; // 返回副本，防止外部修改
        }
    };
})();

// 2. ES6模塊
// user-service.js
export class UserService {
    constructor() {
        this.users = [];
    }
    
    addUser(user) {
        this.users.push(user);
    }
    
    getUsers() {
        return [...this.users];
    }
}

// 3. 單一職責原則
// 每個模塊/類只負責一個功能區域
// auth.js - 處理認證
// api.js - 處理API請求
// user-manager.js - 管理用戶數據
// ui-controller.js - 處理UI更新

// 4. 依賴注入模式
class UserController {
    constructor(userService, authService) {
        this.userService = userService;
        this.authService = authService;
    }
    
    registerUser(userData) {
        if (this.authService.canRegister(userData)) {
            return this.userService.createUser(userData);
        }
        return false;
    }
}</textarea>
                <button class="copy-button" onclick="copyCode('code-organization')">複製</button>
            </div>
            
            <h3>18.5 設計模式</h3>
            <p>設計模式是解決常見軟件設計問題的可重用解決方案。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-design-patterns" readonly>// 1. 單例模式（Singleton）
class Database {
    constructor() {
        if (Database.instance) {
            return Database.instance;
        }
        
        Database.instance = this;
        this.connections = 0;
        console.log('Database initialized');
    }
    
    connect() {
        this.connections++;
        console.log(`New connection established. Total: ${this.connections}`);
    }
}

const db1 = new Database();
const db2 = new Database(); // 返回相同實例
console.log(db1 === db2); // true

// 2. 工廠模式（Factory）
class UserFactory {
    createUser(type, userData) {
        switch (type) {
            case 'admin':
                return new AdminUser(userData);
            case 'regular':
                return new RegularUser(userData);
            case 'guest':
                return new GuestUser(userData);
            default:
                throw new Error(`User type ${type} not supported.`);
        }
    }
}

// 3. 觀察者模式（Observer）
class EventEmitter {
    constructor() {
        this.events = {};
    }
    
    on(event, listener) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(listener);
    }
    
    emit(event, ...args) {
        if (this.events[event]) {
            this.events[event].forEach(listener => listener(...args));
        }
    }
    
    off(event, listener) {
        if (this.events[event]) {
            this.events[event] = this.events[event]
                .filter(l => l !== listener);
        }
    }
}

// 使用示例
const emitter = new EventEmitter();
emitter.on('userCreated', user => console.log('User created:', user));
emitter.emit('userCreated', { name: '小明' });

// 4. 模塊模式（Module）
// 見上一個代碼示例

// 5. 策略模式（Strategy）
class ValidationStrategy {
    validate(value) {
        throw new Error('validate() must be implemented');
    }
}

class RequiredFieldStrategy extends ValidationStrategy {
    validate(value) {
        return value !== null && value !== undefined && value !== '';
    }
}

class EmailStrategy extends ValidationStrategy {
    validate(value) {
        return /\S+@\S+\.\S+/.test(value);
    }
}

class Validator {
    constructor(strategy) {
        this.strategy = strategy;
    }
    
    validate(value) {
        return this.strategy.validate(value);
    }
}</textarea>
                <button class="copy-button" onclick="copyCode('code-design-patterns')">複製</button>
            </div>
            
            <h3>18.6 可維護性與可測試性</h3>
            <p>編寫可維護和可測試的代碼可以減少長期維護成本。</p>
            
            <div class="runnable-code">
                <textarea class="code-editor" id="code-maintainability" readonly>// 1. 編寫小型、可測試的函數
// 難以測試的函數
function validateAndProcessOrder(order) {
    // 驗證
    if (!order.items || order.items.length === 0) {
        alert('訂單中沒有商品！');
        return false;
    }
    
    // 計算總價
    let total = 0;
    for (const item of order.items) {
        total += item.price * item.quantity;
    }
    
    // 應用折扣
    if (total > 1000) {
        total *= 0.9;
    }
    
    // 發送到伺服器
    fetch('/api/orders', {
        method: 'POST',
        body: JSON.stringify({ ...order, total })
    });
    
    // 更新UI
    document.getElementById('orderStatus').textContent = '訂單已提交';
}

// 可測試的版本
function validateOrder(order) {
    return order.items && order.items.length > 0;
}

function calculateOrderTotal(items) {
    return items.reduce((total, item) => total + item.price * item.quantity, 0);
}

function applyDiscount(total) {
    return total > 1000 ? total * 0.9 : total;
}

function submitOrder(order, total) {
    return fetch('/api/orders', {
        method: 'POST',
        body: JSON.stringify({ ...order, total })
    });
}

function updateOrderUI(status) {
    document.getElementById('orderStatus').textContent = status;
}

// 協調函數
async function processOrder(order) {
    if (!validateOrder(order)) {
        alert('訂單中沒有商品！');
        return false;
    }
    
    const subtotal = calculateOrderTotal(order.items);
    const total = applyDiscount(subtotal);
    
    try {
        await submitOrder(order, total);
        updateOrderUI('訂單已提交');
        return true;
    } catch (error) {
        updateOrderUI('訂單提交失敗');
        console.error(error);
        return false;
    }
}

// 2. 依賴注入，使測試更容易
class OrderProcessor {
    constructor(orderService, discountService, notificationService) {
        this.orderService = orderService;
        this.discountService = discountService;
        this.notificationService = notificationService;
    }
    
    async processOrder(order) {
        const validOrder = this.orderService.validateOrder(order);
        if (!validOrder) return false;
        
        const discountedOrder = this.discountService.applyDiscount(order);
        const result = await this.orderService.submitOrder(discountedOrder);
        
        if (result.success) {
            this.notificationService.notify(order.user, '訂單處理成功');
        }
        
        return result.success;
    }
}

// 3. 使用純函數提高可測試性
// 純函數：相同輸入始終產生相同輸出，無副作用
function calculateTax(amount, taxRate) {
    return amount * taxRate;
}

// 測試純函數很簡單
function testCalculateTax() {
    console.assert(calculateTax(100, 0.1) === 10, '稅款計算錯誤');
}</textarea>
                <button class="copy-button" onclick="copyCode('code-maintainability')">複製</button>
            </div>
        </section>
        
        <script>
            // 主題切換功能
            const themeToggleBtn = document.getElementById('theme-toggle');
            const htmlElement = document.documentElement;
            
            themeToggleBtn.addEventListener('click', () => {
                if (htmlElement.getAttribute('data-theme') === 'light') {
                    htmlElement.setAttribute('data-theme', 'dark');
                    localStorage.setItem('theme', 'dark');
                } else {
                    htmlElement.setAttribute('data-theme', 'light');
                    localStorage.setItem('theme', 'light');
                }
            });
            
            // 載入已保存的主題設置
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                htmlElement.setAttribute('data-theme', savedTheme);
            }
            
            // 複製代碼功能
            function copyCode(elementId) {
                const codeElement = document.getElementById(elementId);
                codeElement.select();
                document.execCommand('copy');
                
                const button = codeElement.nextElementSibling;
                const originalText = button.textContent;
                button.textContent = '已複製!';
                
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            }
        </script>
    </main>
    <footer>
        <p>© 2023 JavaScript 完整教學 | 版權所有</p>
    </footer>
</body>
</html>

